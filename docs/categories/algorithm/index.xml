<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Algorithm on Hashnopolis</title>
    <link>http://www.hashnopolis.com/categories/algorithm/</link>
    <description>Recent content in Algorithm on Hashnopolis</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Hashnopolis</copyright>
    <lastBuildDate>Sat, 15 Dec 2018 09:42:45 -0800</lastBuildDate>
    
	<atom:link href="http://www.hashnopolis.com/categories/algorithm/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Find All Anagrams in a String</title>
      <link>http://www.hashnopolis.com/post/2018/12/find-all-anagrams-in-a-string/</link>
      <pubDate>Sat, 15 Dec 2018 09:42:45 -0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/12/find-all-anagrams-in-a-string/</guid>
      <description>Given a string s and a non-empty string p, find all the start indices of p&amp;rsquo;s anagrams in s.
Strings consists of lowercase English letters only and the length of both strings s and p will not be larger than 20,100.
The order of output does not matter.
Example 1:
Input: s: &amp;quot;cbaebabacd&amp;quot; p: &amp;quot;abc&amp;quot; Output: [0, 6] Explanation: The substring with start index = 0 is &amp;quot;cba&amp;quot;, which is an anagram of &amp;quot;abc&amp;quot;.</description>
    </item>
    
    <item>
      <title>Course Schedule</title>
      <link>http://www.hashnopolis.com/post/2018/12/course-schedule/</link>
      <pubDate>Sun, 09 Dec 2018 23:29:18 +0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/12/course-schedule/</guid>
      <description>There are a total of n courses you have to take, labeled from 0 to n-1.
Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1]
Given the total number of courses and a list of prerequisite pairs, is it possible for you to finish all courses?
Example 1:
Input: 2, [[1,0]] Output: true Explanation: There are a total of 2 courses to take.</description>
    </item>
    
    <item>
      <title>Alien Dictionary</title>
      <link>http://www.hashnopolis.com/post/2018/12/alien-dictionary/</link>
      <pubDate>Sat, 08 Dec 2018 23:57:13 +0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/12/alien-dictionary/</guid>
      <description>There is a new alien language which uses the latin alphabet. However, the order among letters are unknown to you. You receive a list of non-empty words from the dictionary, where words are sorted lexicographically by the rules of this new language. Derive the order of letters in this language.
Example 1:
Input: [ &amp;quot;wrt&amp;quot;, &amp;quot;wrf&amp;quot;, &amp;quot;er&amp;quot;, &amp;quot;ett&amp;quot;, &amp;quot;rftt&amp;quot; ] Output: &amp;quot;wertf&amp;quot;  Example 2:
Input: [ &amp;quot;z&amp;quot;, &amp;quot;x&amp;quot; ] Output: &amp;quot;zx&amp;quot;  Example 3:</description>
    </item>
    
    <item>
      <title>Random Pick Index</title>
      <link>http://www.hashnopolis.com/post/2018/12/random-pick-index/</link>
      <pubDate>Sat, 01 Dec 2018 22:27:00 -0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/12/random-pick-index/</guid>
      <description>Given an array of integers with possible duplicates, randomly output the index of a given target number. You can assume that the given target number must exist in the array.
Note: The array size can be very large. Solution that uses too much extra space will not pass the judge.
Example:
int[] nums = new int[] {1,2,3,3,3}; Solution solution = new Solution(nums); // pick(3) should return either index 2, 3, or 4 randomly.</description>
    </item>
    
    <item>
      <title>Intersection of Two Arrays</title>
      <link>http://www.hashnopolis.com/post/2018/11/intersection-of-two-arrays/</link>
      <pubDate>Wed, 28 Nov 2018 23:56:14 -0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/11/intersection-of-two-arrays/</guid>
      <description>Given two arrays, write a function to compute their intersection.
Example 1:
Input: nums1 = [1,2,2,1], nums2 = [2,2] Output: [2]  Example 2:
Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4] Output: [9,4]  Note: - Each element in the result must be unique. - The result can be in any order. Solution:
class Solution: def intersection(self, nums1, nums2): &amp;quot;&amp;quot;&amp;quot; :type nums1: List[int] :type nums2: List[int] :rtype: List[int] &amp;quot;&amp;quot;&amp;quot; res = set([]) dict1 = {} for n in nums1: if dict1.</description>
    </item>
    
    <item>
      <title>Read N Characters Given Read4</title>
      <link>http://www.hashnopolis.com/post/2018/11/read-n-characters-given-read4/</link>
      <pubDate>Mon, 19 Nov 2018 23:52:19 -0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/11/read-n-characters-given-read4/</guid>
      <description>The API: int read4(char *buf) reads 4 characters at a time from a file.
The return value is the actual number of characters read. For example, it returns 3 if there is only 3 characters left in the file.
By using the read4 API, implement the function int read(char *buf, int n)that reads n characters from the file.
Example 1:
Input: buf = &amp;quot;abc&amp;quot;, n = 4 Output: &amp;quot;abc&amp;quot; Explanation: The actual number of characters read is 3, which is &amp;quot;abc&amp;quot;.</description>
    </item>
    
    <item>
      <title>Find the Celebrity</title>
      <link>http://www.hashnopolis.com/post/2018/11/find-the-celebrity/</link>
      <pubDate>Sun, 18 Nov 2018 14:19:34 -0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/11/find-the-celebrity/</guid>
      <description>Suppose you are at a party with n people (labeled from 0 to n - 1) and among them, there may exist one celebrity. The definition of a celebrity is that all the other n - 1 people know him/her but he/she does not know any of them.
Now you want to find out who the celebrity is or verify that there is not one. The only thing you are allowed to do is to ask questions like: &amp;ldquo;Hi, A.</description>
    </item>
    
    <item>
      <title>Longest Consecutive Sequence</title>
      <link>http://www.hashnopolis.com/post/2018/11/longest-consecutive-sequence/</link>
      <pubDate>Wed, 14 Nov 2018 12:01:01 -0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/11/longest-consecutive-sequence/</guid>
      <description>Given an unsorted array of integers, find the length of the longest consecutive elements sequence.
Your algorithm should run in O(n) complexity.
Example:
Input: [100, 4, 200, 1, 3, 2] Output: 4 Explanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4.  Solution:
# Time: o(n) class Solution(object): def longestConsecutive(self, nums): &amp;quot;&amp;quot;&amp;quot; :type nums: List[int] :rtype: int &amp;quot;&amp;quot;&amp;quot; if nums is None or len(nums) == 0: return 0 map = {} maxLen = 0; for num in nums: if num in map: # skip duplicates continue # initialize ranges low, upp = num, num if num - 1 in map: low = map.</description>
    </item>
    
    <item>
      <title>Flatten Nested List Iterator</title>
      <link>http://www.hashnopolis.com/post/2018/11/flatten-nested-list-iterator/</link>
      <pubDate>Tue, 13 Nov 2018 20:03:07 -0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/11/flatten-nested-list-iterator/</guid>
      <description>Given a nested list of integers, implement an iterator to flatten it.
Each element is either an integer, or a list &amp;ndash; whose elements may also be integers or other lists.
Example 1:
Input: [[1,1],2,[1,1]] Output: [1,1,2,1,1] Explanation: By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: `[1,1,2,1,1]`.  Example 2:
Input: [1,[4,[6]]] Output: [1,4,6] Explanation: By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: `[1,4,6]`.</description>
    </item>
    
    <item>
      <title>Reverse Nodes in K Group</title>
      <link>http://www.hashnopolis.com/post/2018/11/reverse-nodes-in-k-group/</link>
      <pubDate>Tue, 13 Nov 2018 18:04:36 -0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/11/reverse-nodes-in-k-group/</guid>
      <description>Given a linked list, reverse the nodes of a linked list k at a time and return its modified list.
k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.
Example: Given this linked list: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5
For k = 2, you should return: 2-&amp;gt;1-&amp;gt;4-&amp;gt;3-&amp;gt;5</description>
    </item>
    
    <item>
      <title>Serialize and Deserialize Binary Tree</title>
      <link>http://www.hashnopolis.com/post/2018/11/serialize-and-deserialize-binary-tree/</link>
      <pubDate>Tue, 13 Nov 2018 17:31:13 -0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/11/serialize-and-deserialize-binary-tree/</guid>
      <description>Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.
Design an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure.</description>
    </item>
    
    <item>
      <title>Encode and Decode Tinyurl</title>
      <link>http://www.hashnopolis.com/post/2018/11/encode-and-decode-tinyurl/</link>
      <pubDate>Sun, 11 Nov 2018 18:48:12 -0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/11/encode-and-decode-tinyurl/</guid>
      <description>Note: This is a companion problem to the System Design problem: Design TinyURL. TinyURL is a URL shortening service where you enter a URL such as https://leetcode.com/problems/design-tinyurl and it returns a short URL such as http://tinyurl.com/4e9iAk.
Design the encode and decode methods for the TinyURL service. There is no restriction on how your encode/decode algorithm should work. You just need to ensure that a URL can be encoded to a tiny URL and the tiny URL can be decoded to the original URL.</description>
    </item>
    
    <item>
      <title>Meeting Rooms II</title>
      <link>http://www.hashnopolis.com/post/2018/11/meeting-rooms-ii/</link>
      <pubDate>Sun, 11 Nov 2018 17:11:19 -0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/11/meeting-rooms-ii/</guid>
      <description>Given an array of meeting time intervals consisting of start and end times [[s1,e1],[s2,e2],...] (si &amp;lt; ei), find the minimum number of conference rooms required.
Example 1:
Input: [[0, 30],[5, 10],[15, 20]] Output: 2  Example 2:
Input: [[7,10],[2,4]] Output: 1  Solution:
# Definition for an interval. # class Interval: # def __init__(self, s=0, e=0): # self.start = s # self.end = e # |____| |_______| # |_______| |____| # Number of meeting rooms: 2 class Solution(object): def minMeetingRooms(self, intervals): &amp;quot;&amp;quot;&amp;quot; :type intervals: List[Interval] :rtype: int &amp;quot;&amp;quot;&amp;quot; starts, ends = [], [] length = len(intervals) for i in range(length): starts.</description>
    </item>
    
    <item>
      <title>LRU Cache</title>
      <link>http://www.hashnopolis.com/post/2018/11/lru-cache/</link>
      <pubDate>Sun, 11 Nov 2018 15:33:09 -0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/11/lru-cache/</guid>
      <description>Design and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: get and put.
get(key) - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1. put(key, value) - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item.</description>
    </item>
    
    <item>
      <title>Interger to English Words</title>
      <link>http://www.hashnopolis.com/post/2018/11/interger-to-english-words/</link>
      <pubDate>Sun, 11 Nov 2018 13:27:05 -0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/11/interger-to-english-words/</guid>
      <description>Convert a non-negative integer to its english words representation. Given input is guaranteed to be less than 231 - 1.
Example 1:
Input: 123 Output: &amp;quot;One Hundred Twenty Three&amp;quot;  Example 2:
Input: 12345 Output: &amp;quot;Twelve Thousand Three Hundred Forty Five&amp;quot;  Example 3:
Input: 1234567 Output: &amp;quot;One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven&amp;quot;  Example 4:
Input: 1234567891 Output: &amp;quot;One Billion Two Hundred Thirty Four Million Five Hundred Sixty Seven Thousand Eight Hundred Ninety One&amp;quot;  Solution:</description>
    </item>
    
    <item>
      <title>PowX N</title>
      <link>http://www.hashnopolis.com/post/2018/11/powx-n/</link>
      <pubDate>Sun, 11 Nov 2018 12:40:25 -0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/11/powx-n/</guid>
      <description>Example 1:
Input: 2.00000, 10 Output: 1024.00000  Example 2:
Input: 2.10000, 3 Output: 9.26100  Example 3:
Input: 2.00000, -2 Output: 0.25000  Explanation: 2-2 = 1&amp;frasl;22 = 1&amp;frasl;4 = 0.25 Note: - -100.0 &amp;lt; x &amp;lt; 100.0 - n is a 32-bit signed integer, within the range [−231, 231 − 1] Solution:
# Time: o(logN) # Space: o(n) class Solution: def myPow(self, x, n): &amp;quot;&amp;quot;&amp;quot; :type x: float :type n: int :rtype: float &amp;quot;&amp;quot;&amp;quot; if n &amp;gt; 0: return self.</description>
    </item>
    
    <item>
      <title>Validate Binary Search Tree</title>
      <link>http://www.hashnopolis.com/post/2018/11/validate-binary-search-tree/</link>
      <pubDate>Sat, 10 Nov 2018 22:50:21 -0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/11/validate-binary-search-tree/</guid>
      <description>Given a binary tree, determine if it is a valid binary search tree (BST).
Assume a BST is defined as follows: - The left subtree of a node contains only nodes with keys less than the node&amp;rsquo;s key. - The right subtree of a node contains only nodes with keys greater than the node&amp;rsquo;s key. - Both the left and right subtrees must also be binary search trees. Example 1:</description>
    </item>
    
    <item>
      <title>Count Primes</title>
      <link>http://www.hashnopolis.com/post/2018/11/count-primes/</link>
      <pubDate>Fri, 09 Nov 2018 18:52:59 -0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/11/count-primes/</guid>
      <description>Count the number of prime numbers less than a non-negative number, n.
Example:
Input: 10 Output: 4  Explanation: There are 4 prime numbers less than 10, they are 2, 3, 5, 7. Solution:
class Solution: def countPrimes(self, n): &amp;quot;&amp;quot;&amp;quot; :type n: int :rtype: int &amp;quot;&amp;quot;&amp;quot; if n &amp;lt;= 2: return 0 marked = [0] * (n-1) for i in range(int(n**0.5)+1): if marked[i] != 1: prime = i + 2 for j in range(prime**2-2, n-1, prime): marked[j] = 1 count = 0 for c, k in enumerate(marked): # We are counting numbers less than n, hence len(marked)-1 if k == 0 and c &amp;lt; len(marked)-1: count += 1 return count  </description>
    </item>
    
    <item>
      <title>Implement Trie Prefix Tree</title>
      <link>http://www.hashnopolis.com/post/2018/11/implement-trie-prefix-tree/</link>
      <pubDate>Thu, 08 Nov 2018 23:07:10 -0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/11/implement-trie-prefix-tree/</guid>
      <description>Implement a trie with insert, search, and startsWith methods.
Example:
Trie trie = new Trie(); trie.insert(&amp;quot;apple&amp;quot;); trie.search(&amp;quot;apple&amp;quot;); // returns true trie.search(&amp;quot;app&amp;quot;); // returns false trie.startsWith(&amp;quot;app&amp;quot;); // returns true trie.insert(&amp;quot;app&amp;quot;); trie.search(&amp;quot;app&amp;quot;); // returns true  Note: You may assume that all inputs are consist of lowercase letters a-z. All inputs are guaranteed to be non-empty strings. Solution:
# o(n) class TrieNode(): def __init__(self): self.children = {} self.isWholeWord = False class Trie: def __init__(self): &amp;quot;&amp;quot;&amp;quot; Initialize your data structure here.</description>
    </item>
    
    <item>
      <title>Excel Sheet Column Title</title>
      <link>http://www.hashnopolis.com/post/2018/11/excel-sheet-column-title/</link>
      <pubDate>Thu, 08 Nov 2018 22:42:24 -0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/11/excel-sheet-column-title/</guid>
      <description>Given a positive integer, return its corresponding column title as appear in an Excel sheet.
For example:
 1 -&amp;gt; A 2 -&amp;gt; B 3 -&amp;gt; C ... 26 -&amp;gt; Z 27 -&amp;gt; AA 28 -&amp;gt; AB ...  Example 1:
Input: 1 Output: &amp;quot;A&amp;quot;  Example 2:
Input: 28 Output: &amp;quot;AB&amp;quot;  Example 3:
Input: 701 Output: &amp;quot;ZY&amp;quot;  Solution:
class Solution: def convertToTitle(self, n): &amp;quot;&amp;quot;&amp;quot; :type n: int :rtype: str &amp;quot;&amp;quot;&amp;quot; digit = 1 res = &amp;quot;&amp;quot; while n &amp;gt; 0: # Because we start from A.</description>
    </item>
    
    <item>
      <title>Increasing Triplet Subsequence</title>
      <link>http://www.hashnopolis.com/post/2018/11/increasing-triplet-subsequence/</link>
      <pubDate>Thu, 08 Nov 2018 22:10:52 -0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/11/increasing-triplet-subsequence/</guid>
      <description>Given an unsorted array return whether an increasing subsequence of length 3 exists or not in the array.
Formally the function should:
Return true if there exists i, j, k such that arr[i] &amp;lt; arr[j] &amp;lt; arr[k] given 0 ≤ i &amp;lt; j &amp;lt; k ≤ n-1 else return false. Note: Your algorithm should run in O(n) time complexity and O(1) space complexity.
Example 1:
Input: [1,2,3,4,5] Output: true  Example 2:</description>
    </item>
    
    <item>
      <title>Simplify Path</title>
      <link>http://www.hashnopolis.com/post/2018/11/simplify-path/</link>
      <pubDate>Thu, 08 Nov 2018 22:02:51 -0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/11/simplify-path/</guid>
      <description>Given an absolute path for a file (Unix-style), simplify it.
For example, path = &amp;quot;/home/&amp;quot;, =&amp;gt; &amp;quot;/home&amp;quot; path = &amp;quot;/a/./b/../../c/&amp;quot;, =&amp;gt; &amp;quot;/c&amp;quot; path = &amp;quot;/a/../../b/../c//.//&amp;quot;, =&amp;gt; &amp;quot;/c&amp;quot; path = &amp;quot;/a//b////c/d//././/..&amp;quot;, =&amp;gt; &amp;quot;/a/b/c&amp;quot;
In a UNIX-style file system, a period (&amp;lsquo;.&amp;rsquo;) refers to the current directory, so it can be ignored in a simplified path. Additionally, a double period (&amp;ldquo;..&amp;rdquo;) moves up a directory, so it cancels out whatever the last directory was.</description>
    </item>
    
    <item>
      <title>Sqrtx</title>
      <link>http://www.hashnopolis.com/post/2018/11/sqrtx/</link>
      <pubDate>Thu, 08 Nov 2018 21:59:03 -0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/11/sqrtx/</guid>
      <description>Implement int sqrt(int x).
Compute and return the square root of x, where x is guaranteed to be a non-negative integer.
Since the return type is an integer, the decimal digits are truncated and only the integer part of the result is returned.
Example 1:
Input: 4 Output: 2  Example 2:
Input: 8 Output: 2  Explanation: The square root of 8 is 2.82842&amp;hellip;, and since the decimal part is truncated, 2 is returned.</description>
    </item>
    
    <item>
      <title>Sort Colors</title>
      <link>http://www.hashnopolis.com/post/2018/11/sort-colors/</link>
      <pubDate>Wed, 07 Nov 2018 10:46:26 -0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/11/sort-colors/</guid>
      <description>Given an array with n objects colored red, white or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white and blue.
Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively.
Note: You are not suppose to use the library&amp;rsquo;s sort function for this problem. Example:
Input: [2,0,2,1,1,0] Output: [0,0,1,1,2,2]  Follow up: 1.</description>
    </item>
    
    <item>
      <title>Missing Words</title>
      <link>http://www.hashnopolis.com/post/2018/11/missing-words/</link>
      <pubDate>Tue, 06 Nov 2018 17:03:07 -0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/11/missing-words/</guid>
      <description>Julia and Samantha are playing with strings. Julia has a string S, and Samantha has a string T which is a subsequence of string S. They are trying to find out what words are missing in T. Help Julia and Samantha to solve the problem. List all the missing words in T, such that inserting them at the appropriate positions in T, in the same order, results in the string S.</description>
    </item>
    
    <item>
      <title>Product of Array Except Self</title>
      <link>http://www.hashnopolis.com/post/2018/11/product-of-array-except-self/</link>
      <pubDate>Sat, 03 Nov 2018 16:41:47 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/11/product-of-array-except-self/</guid>
      <description>Given an array of n integers where n &amp;gt; 1, nums, return an array output such that output[i] is equal to the product of all the elements of nums except nums[i].
Solve it without division and in O(n).
For example, given [1,2,3,4], return [24,12,8,6].
Follow up: Could you solve it with constant space complexity? (Note: The output array does not count as extra space for the purpose of space complexity analysis.</description>
    </item>
    
    <item>
      <title>Move Zeroes</title>
      <link>http://www.hashnopolis.com/post/2018/11/move-zeroes/</link>
      <pubDate>Sat, 03 Nov 2018 16:25:23 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/11/move-zeroes/</guid>
      <description>Given an array nums, write a function to move all 0&amp;rsquo;s to the end of it while maintaining the relative order of the non-zero elements.
For example, given nums = [0, 1, 0, 3, 12], after calling your function, nums should be [1, 3, 12, 0, 0].
Note: You must do this in-place without making a copy of the array. Minimize the total number of operations. Credits: Special thanks to @jianchao.</description>
    </item>
    
    <item>
      <title>Count and Say</title>
      <link>http://www.hashnopolis.com/post/2018/11/count-and-say/</link>
      <pubDate>Sat, 03 Nov 2018 16:07:54 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/11/count-and-say/</guid>
      <description>The count-and-say sequence is the sequence of integers with the first five terms as following:
 1 11 21 1211 111221 1 is read off as &amp;quot;one 1&amp;quot; or 11. 11 is read off as &amp;quot;two 1s&amp;quot; or 21. 21 is read off as &amp;quot;one 2, then one 1&amp;quot; or 1211.  Given an integer n where 1 ≤ n ≤ 30, generate the nth term of the count-and-say sequence.</description>
    </item>
    
    <item>
      <title>Implement Strstr</title>
      <link>http://www.hashnopolis.com/post/2018/11/implement-strstr/</link>
      <pubDate>Sat, 03 Nov 2018 01:46:24 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/11/implement-strstr/</guid>
      <description>Implement strstr().
Return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.
Example 1:
Input: haystack = &amp;quot;hello&amp;quot;, needle = &amp;quot;ll&amp;quot; Output: 2  Example 2:
Input: haystack = &amp;quot;aaaaa&amp;quot;, needle = &amp;quot;bba&amp;quot; Output: -1  Clarification:
What should we return when needle is an empty string? This is a great question to ask during an interview.
For the purpose of this problem, we will return 0 when needle is an empty string.</description>
    </item>
    
    <item>
      <title>Valid Parentheses</title>
      <link>http://www.hashnopolis.com/post/2018/11/valid-parentheses/</link>
      <pubDate>Fri, 02 Nov 2018 20:30:23 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/11/valid-parentheses/</guid>
      <description>Given a string containing just the characters &amp;lsquo;(&amp;rsquo;, &amp;lsquo;)&amp;rsquo;, &amp;lsquo;{&amp;rsquo;, &amp;lsquo;}&amp;rsquo;, &amp;lsquo;[&amp;rsquo; and &amp;lsquo;]&amp;rsquo;, determine if the input string is valid.
An input string is valid if:
Open brackets must be closed by the same type of brackets. Open brackets must be closed in the correct order. Note that an empty string is also considered valid.
Example 1:
Input: &amp;quot;()&amp;quot; Output: true  Example 2:
Input: &amp;quot;()[]{}&amp;quot; Output: true  Example 3:</description>
    </item>
    
    <item>
      <title>Maximal Square</title>
      <link>http://www.hashnopolis.com/post/2018/11/maximal-square/</link>
      <pubDate>Thu, 01 Nov 2018 23:18:11 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/11/maximal-square/</guid>
      <description>Given a 2D binary matrix filled with 0&amp;rsquo;s and 1&amp;rsquo;s, find the largest square containing only 1&amp;rsquo;s and return its area.
Example: Input:
1 0 1 0 0
1 0 1 1 1
1 1 1 1 1
1 0 0 1 0
Output: 4 Solution:
class Solution: def maximalSquare(self, matrix): &amp;quot;&amp;quot;&amp;quot; :type matrix: List[List[str]] :rtype: int &amp;quot;&amp;quot;&amp;quot; area = 0 if not matrix: return area # Edge case: single col matrix for i in range(len(matrix)): if matrix[i][0] == &amp;quot;1&amp;quot;: matrix[i][0] = 1 area = 1 # Edge case: single row matrix for i in range(len(matrix[0])): if matrix[0][i] == &amp;quot;1&amp;quot;: matrix[0][i] = 1 area = 1 for i in range(1, len(matrix)): for j in range(1, len(matrix[0])): if matrix[i][j] == &amp;quot;0&amp;quot;: matrix[i][j] = 0 continue localMin = min( int(matrix[i-1][j]), int(matrix[i-1][j-1]), int(matrix[i][j-1]) ) print(int(matrix[i-1][j]), int(matrix[i-1][j-1]), int(matrix[i][j-1])) matrix[i][j] = localMin + 1 if matrix[i][j] &amp;gt; area: area = matrix[i][j] return area**2  </description>
    </item>
    
    <item>
      <title>Valid Palindrome</title>
      <link>http://www.hashnopolis.com/post/2018/11/valid-palindrome/</link>
      <pubDate>Thu, 01 Nov 2018 22:39:07 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/11/valid-palindrome/</guid>
      <description>Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.
Note: For the purpose of this problem, we define empty string as valid palindrome.
Example 1:
Input: &amp;quot;A man, a plan, a canal: Panama&amp;quot; Output: true  Example 2:
Input: &amp;quot;race a car&amp;quot; Output: false  Solution:
class Solution: def isPalindrome(self, s): &amp;quot;&amp;quot;&amp;quot; :type s: str :rtype: bool &amp;quot;&amp;quot;&amp;quot; if not s: return True head = 0 tail = len(s) - 1 while head &amp;lt;= tail: cHead, cTail = s[head], s[tail] if not cHead.</description>
    </item>
    
    <item>
      <title>Lowest Common Ancestor of a Binary Search Tree</title>
      <link>http://www.hashnopolis.com/post/2018/11/lowest-common-ancestor-of-a-binary-search-tree/</link>
      <pubDate>Thu, 01 Nov 2018 13:23:27 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/11/lowest-common-ancestor-of-a-binary-search-tree/</guid>
      <description>Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST.
According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).”
Given binary search tree: root = [6,2,8,0,4,7,9,null,null,3,5]</description>
    </item>
    
    <item>
      <title>Lowest Common Ancestor of a Binary Tree</title>
      <link>http://www.hashnopolis.com/post/2018/11/lowest-common-ancestor-of-a-binary-tree/</link>
      <pubDate>Thu, 01 Nov 2018 13:18:53 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/11/lowest-common-ancestor-of-a-binary-tree/</guid>
      <description>Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.
According to the : “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).”
Given the following binary tree: root = [3,5,1,6,2,0,8,null,null,7,4]
 _______3______ / \ ___5__ ___1__  / \ / 6 _2 0 8 / 7 4 Example 1:</description>
    </item>
    
    <item>
      <title>Summary Ranges</title>
      <link>http://www.hashnopolis.com/post/2018/10/summary-ranges/</link>
      <pubDate>Wed, 31 Oct 2018 23:53:52 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/10/summary-ranges/</guid>
      <description>Given a sorted integer array without duplicates, return the summary of its ranges.
Example 1:
Input: [0,1,2,4,5,7] Output: [&amp;quot;0-&amp;gt;2&amp;quot;,&amp;quot;4-&amp;gt;5&amp;quot;,&amp;quot;7&amp;quot;] Explanation: 0,1,2 form a continuous range; 4,5 form a continuous range.  Example 2:
Input: [0,2,3,4,6,8,9] Output: [&amp;quot;0&amp;quot;,&amp;quot;2-&amp;gt;4&amp;quot;,&amp;quot;6&amp;quot;,&amp;quot;8-&amp;gt;9&amp;quot;] Explanation: 2,3,4 form a continuous range; 8,9 form a continuous range.  Solution:
class Solution: def summaryRanges(self, nums): &amp;quot;&amp;quot;&amp;quot; :type nums: List[int] :rtype: List[str] &amp;quot;&amp;quot;&amp;quot; if not nums: return [] ranges = [str(nums[0])] for i in range(len(nums)-1): if nums[i+1] == nums[i] + 1: print(ranges) ranges[len(ranges)-1] = ranges[len(ranges)-1].</description>
    </item>
    
    <item>
      <title>Search a 2D Matrix</title>
      <link>http://www.hashnopolis.com/post/2018/10/search-a-2d-matrix/</link>
      <pubDate>Tue, 30 Oct 2018 23:56:03 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/10/search-a-2d-matrix/</guid>
      <description>Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties: - Integers in each row are sorted from left to right. - The first integer of each row is greater than the last integer of the previous row. Example 1:
Input: matrix = [ [1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 50] ] target = 3 Output: true  Example 2:</description>
    </item>
    
    <item>
      <title>Find the Duplicate Number</title>
      <link>http://www.hashnopolis.com/post/2018/10/find-the-duplicate-number/</link>
      <pubDate>Sat, 27 Oct 2018 10:34:19 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/10/find-the-duplicate-number/</guid>
      <description>Given an array nums containing n + 1 integers where each integer is between 1 and n (inclusive), prove that at least one duplicate number must exist. Assume that there is only one duplicate number, find the duplicate one.
Example 1:
Input: [1,3,4,2,2] Output: 2  Example 2:
Input: [3,1,3,4,2] Output: 3  Note: You must not modify the array (assume the array is read only). You must use only constant, O(1) extra space.</description>
    </item>
    
    <item>
      <title>H-Index</title>
      <link>http://www.hashnopolis.com/post/2018/10/h-index/</link>
      <pubDate>Sat, 27 Oct 2018 01:07:05 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/10/h-index/</guid>
      <description>Given an array of citations (each citation is a non-negative integer) of a researcher, write a function to compute the researcher&amp;rsquo;s h-index.
According to the definition of h-index on Wikipedia: &amp;ldquo;A scientist has index h if h of his/her N papers have at least h citations each, and the other N − h papers have no more than h citations each.&amp;rdquo;
Example:
Input: citations = [3,0,6,1,5] Output: 3  Explanation: [3,0,6,1,5] means the researcher has 5 papers in total and each of them had received 3, 0, 6, 1, 5 citations respectively.</description>
    </item>
    
    <item>
      <title>Word Ladder</title>
      <link>http://www.hashnopolis.com/post/2018/10/word-ladder/</link>
      <pubDate>Sat, 27 Oct 2018 01:05:07 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/10/word-ladder/</guid>
      <description>Given two words (beginWord and endWord), and a dictionary&amp;rsquo;s word list, find the length of shortest transformation sequence from beginWord to endWord, such that: 1. Only one letter can be changed at a time. 2. Each transformed word must exist in the word list. Note that beginWord is not a transformed word. Note: - Return 0 if there is no such transformation sequence. - All words have the same length. - All words contain only lowercase alphabetic characters.</description>
    </item>
    
    <item>
      <title>Invert Binary Tree</title>
      <link>http://www.hashnopolis.com/post/2018/10/invert-binary-tree/</link>
      <pubDate>Fri, 26 Oct 2018 23:12:09 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/10/invert-binary-tree/</guid>
      <description>Invert a binary tree.
 4 / \ 2 7 / \ / \ 1 3 6 9  to
 4 / \ 7 2 / \ / \ 9 6 3 1  Thoughts What if a node is NULL? A NULL has no children, so how to iterate deeper into the tree?
// Attempt // class Solution { // public: void swapNodes(*leftNode, *rightNode) { *temp = *leftNode; *leftNode = *rightNode; *rightNode = temp; return; } TreeNode* invertTree(TreeNode* root) { if (root == NULL) return invertTree(root-&amp;gt;left, ) } };  Solution:</description>
    </item>
    
    <item>
      <title>Integer to Roman</title>
      <link>http://www.hashnopolis.com/post/2018/10/integer-to-roman/</link>
      <pubDate>Fri, 26 Oct 2018 23:11:27 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/10/integer-to-roman/</guid>
      <description>Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.
Symbol Value I 1 V 5 X 10 L 50 C 100 D 500 M 1000  For example, two is written as II in Roman numeral, just two one&amp;rsquo;s added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II.</description>
    </item>
    
    <item>
      <title>Find First and Last Position of Element in Sorted Array</title>
      <link>http://www.hashnopolis.com/post/2018/10/find-first-and-last-position-of-element-in-sorted-array/</link>
      <pubDate>Fri, 26 Oct 2018 23:10:23 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/10/find-first-and-last-position-of-element-in-sorted-array/</guid>
      <description>Given an array of integers nums sorted in ascending order, find the starting and ending position of a given target value.
Your algorithm&amp;rsquo;s runtime complexity must be in the order of O(log n).
If the target is not found in the array, return [-1, -1].
Example 1:
Input: nums = [5,7,7,8,8,10], target = 8 Output: [3,4]  Example 2:
Input: nums = [5,7,7,8,8,10], target = 6 Output: [-1,-1]  Solution:</description>
    </item>
    
    <item>
      <title>Search in Rotated Sorted Array</title>
      <link>http://www.hashnopolis.com/post/2018/10/search-in-rotated-sorted-array/</link>
      <pubDate>Fri, 26 Oct 2018 23:08:49 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/10/search-in-rotated-sorted-array/</guid>
      <description>Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.
(i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]).
You are given a target value to search. If found in the array return its index, otherwise return -1.
You may assume no duplicate exists in the array.
Your algorithm&amp;rsquo;s runtime complexity must be in the order of O(log n).
Example 1:
Input: nums = [4,5,6,7,0,1,2], target = 0 Output: 4  Example 2:</description>
    </item>
    
    <item>
      <title>First Bad Version</title>
      <link>http://www.hashnopolis.com/post/2018/10/first-bad-version/</link>
      <pubDate>Fri, 26 Oct 2018 23:07:46 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/10/first-bad-version/</guid>
      <description>You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.
Suppose you have n versions [1, 2, ..., n] and you want to find out the first bad one, which causes all the following ones to be bad.</description>
    </item>
    
    <item>
      <title>Minimum Path Sum</title>
      <link>http://www.hashnopolis.com/post/2018/10/minimum-path-sum/</link>
      <pubDate>Fri, 26 Oct 2018 23:04:31 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/10/minimum-path-sum/</guid>
      <description>Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path.
Note: You can only move either down or right at any point in time.
Example:
Input: [ [1,3,1], [1,5,1], [4,2,1] ] Output: 7  Explanation: Because the path 1→3→1→1→1 minimizes the sum. Solution:
class Solution: def minPathSum(self, grid): &amp;quot;&amp;quot;&amp;quot; :type grid: List[List[int]] :rtype: int &amp;quot;&amp;quot;&amp;quot; for r in range(len(grid)): for c in range(len(grid[0])): if (r == 0 and c !</description>
    </item>
    
    <item>
      <title>House Robber</title>
      <link>http://www.hashnopolis.com/post/2018/10/house-robber/</link>
      <pubDate>Thu, 25 Oct 2018 23:45:32 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/10/house-robber/</guid>
      <description>You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night.
Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.</description>
    </item>
    
    <item>
      <title>Happy Number</title>
      <link>http://www.hashnopolis.com/post/2018/10/happy-number/</link>
      <pubDate>Thu, 25 Oct 2018 23:44:12 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/10/happy-number/</guid>
      <description>Write an algorithm to determine if a number is &amp;ldquo;happy&amp;rdquo;.
A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy numbers.</description>
    </item>
    
    <item>
      <title>Merge Two Sorted Lists</title>
      <link>http://www.hashnopolis.com/post/2018/10/merge-two-sorted-lists/</link>
      <pubDate>Thu, 25 Oct 2018 23:43:25 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/10/merge-two-sorted-lists/</guid>
      <description>Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.
Example:
Input: 1-&amp;gt;2-&amp;gt;4, 1-&amp;gt;3-&amp;gt;4 Output: 1-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;4  Solution:
class Solution: def mergeTwoLists(self, l1, l2): &amp;quot;&amp;quot;&amp;quot; :type l1: ListNode :type l2: ListNode :rtype: ListNode &amp;quot;&amp;quot;&amp;quot; if l1 == None: return l2 if l2 == None: return l1 root = ListNode(0) temp = root while l1 and l2: if l1.</description>
    </item>
    
    <item>
      <title>Merge Two Binary Trees</title>
      <link>http://www.hashnopolis.com/post/2018/10/merge-two-binary-trees/</link>
      <pubDate>Thu, 25 Oct 2018 23:42:27 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/10/merge-two-binary-trees/</guid>
      <description>Given two binary trees and imagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not.
You need to merge them into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node. Otherwise, the NOT null node will be used as the node of new tree.</description>
    </item>
    
    <item>
      <title>Multiply Strings</title>
      <link>http://www.hashnopolis.com/post/2018/10/multiply-strings/</link>
      <pubDate>Thu, 25 Oct 2018 23:40:08 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/10/multiply-strings/</guid>
      <description>Given two non-negative integers num1 and num2 represented as strings, return the product of num1 and num2, also represented as a string.
Example 1:
Input: num1 = &amp;quot;2&amp;quot;, num2 = &amp;quot;3&amp;quot; Output: &amp;quot;6&amp;quot;  Example 2:
Input: num1 = &amp;quot;123&amp;quot;, num2 = &amp;quot;456&amp;quot; Output: &amp;quot;56088&amp;quot;  Note: - The length of both num1 and num2 is &amp;lt; 110. - Both num1 and num2 contain only digits 0-9. - Both num1 and num2 do not contain any leading zero, except the number 0 itself.</description>
    </item>
    
    <item>
      <title>Kth Smallest Element in a BST</title>
      <link>http://www.hashnopolis.com/post/2018/10/kth-smallest-element-in-a-bst/</link>
      <pubDate>Wed, 24 Oct 2018 23:39:48 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/10/kth-smallest-element-in-a-bst/</guid>
      <description>Given a binary search tree, write a function kthSmallest to find the kth smallest element in it.
Note:
You may assume k is always valid, 1 ≤ k ≤ BST&#39;s total elements.  Example 1:
Input: root = [3,1,4,null,2], k = 1 Output: 1  Example 2: ```` Input: root = [5,3,6,2,4,null,null,1], k = 3 Output: 3
**Follow up:** What if the BST is modified (insert/delete operations) often and you need to find the kth smallest frequently?</description>
    </item>
    
    <item>
      <title>Kth Largest Element in an Array</title>
      <link>http://www.hashnopolis.com/post/2018/10/kth-largest-element-in-an-array/</link>
      <pubDate>Wed, 24 Oct 2018 23:38:20 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/10/kth-largest-element-in-an-array/</guid>
      <description>Find the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element.
Example 1:
Input: [3,2,1,5,6,4] and k = 2 Output: 5  Example 2:
Input: [3,2,3,1,2,4,5,5,6] and k = 4 Output: 4  Note: You may assume k is always valid, 1 ≤ k ≤ array&#39;s length. Solution:
class Solution: def findKthLargest(self, nums, k): if (nums == None or len(nums) == 0): return 0 left, right = 0, len(nums) - 1 def swap(nums, i, j): temp = nums[i] nums[i] = nums[j] nums[j] = temp def partition(nums, left, right): pivot = nums[left] l = left + 1 r = right while l &amp;lt;= r: if nums[l] &amp;lt; pivot and nums[r] &amp;gt; pivot: swap(nums, l, r) l += 1 r -= 1 if nums[l] &amp;gt;= pivot: l += 1 if nums[r] &amp;lt;= pivot: r -= 1 swap(nums, left, r) return r while True: pos = partition(nums, left, right) if pos + 1 == k: return nums[pos] elif pos + 1 &amp;gt; k: right = pos - 1 elif pos + 1 &amp;lt; k: left = pos + 1  </description>
    </item>
    
    <item>
      <title>Group Anagrams</title>
      <link>http://www.hashnopolis.com/post/2018/10/group-anagrams/</link>
      <pubDate>Mon, 22 Oct 2018 12:01:59 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/10/group-anagrams/</guid>
      <description>Given an array of strings, group anagrams together.
Example:
Input: [&amp;quot;eat&amp;quot;, &amp;quot;tea&amp;quot;, &amp;quot;tan&amp;quot;, &amp;quot;ate&amp;quot;, &amp;quot;nat&amp;quot;, &amp;quot;bat&amp;quot;], Output: [ [&amp;quot;ate&amp;quot;,&amp;quot;eat&amp;quot;,&amp;quot;tea&amp;quot;], [&amp;quot;nat&amp;quot;,&amp;quot;tan&amp;quot;], [&amp;quot;bat&amp;quot;] ]  Note: - All inputs will be in lowercase. - The order of your output does not matter. Solution:
class Solution(object): def groupAnagrams(self, strs): &amp;quot;&amp;quot;&amp;quot; :type strs: List[str] :rtype: List[List[str]] &amp;quot;&amp;quot;&amp;quot; primeNums = { &amp;quot;a&amp;quot;: 2, &amp;quot;b&amp;quot;: 3, &amp;quot;c&amp;quot;: 5, &amp;quot;d&amp;quot;: 7, &amp;quot;e&amp;quot;: 11, &amp;quot;f&amp;quot;: 13, &amp;quot;g&amp;quot;: 17, &amp;quot;h&amp;quot;: 19, &amp;quot;i&amp;quot;: 23, &amp;quot;j&amp;quot;: 29, &amp;quot;k&amp;quot;: 31, &amp;quot;m&amp;quot;: 37, &amp;quot;l&amp;quot;: 41, &amp;quot;n&amp;quot;: 43, &amp;quot;o&amp;quot;: 47, &amp;quot;p&amp;quot;: 53, &amp;quot;q&amp;quot;: 59, &amp;quot;r&amp;quot;: 61, &amp;quot;s&amp;quot;: 67, &amp;quot;t&amp;quot;: 71, &amp;quot;u&amp;quot;: 73, &amp;quot;v&amp;quot;: 79, &amp;quot;w&amp;quot;: 83, &amp;quot;x&amp;quot;: 89, &amp;quot;y&amp;quot;: 97, &amp;quot;z&amp;quot;: 101 } def encode(string): res = 1 for s in list(string): res *= primeNums[s] return res anagrams = {} for string in strs: code = encode(string) if anagrams.</description>
    </item>
    
    <item>
      <title>Linked List Cycle II</title>
      <link>http://www.hashnopolis.com/post/2018/10/linked-list-cycle-ii/</link>
      <pubDate>Sun, 21 Oct 2018 23:08:30 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/10/linked-list-cycle-ii/</guid>
      <description>Given a linked list, return the node where the cycle begins. If there is no cycle, return null.
Note: Do not modify the linked list.
Follow up: Can you solve it without using extra space? Solution:
# Definition for singly-linked list. # class ListNode(object): # def __init__(self, x): # self.val = x # self.next = None class Solution(object): def detectCycle(self, head): &amp;quot;&amp;quot;&amp;quot; :type head: ListNode :rtype: ListNode &amp;quot;&amp;quot;&amp;quot; if head == None: return None slow = head fast = head hasCycle = False while fast.</description>
    </item>
    
    <item>
      <title>Linked List Cycle</title>
      <link>http://www.hashnopolis.com/post/2018/10/linked-list-cycle/</link>
      <pubDate>Sun, 21 Oct 2018 23:07:55 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/10/linked-list-cycle/</guid>
      <description>Given a linked list, determine if it has a cycle in it.
Follow up: Can you solve it without using extra space?
Solution:
# Definition for singly-linked list. # class ListNode(object): # def __init__(self, x): # self.val = x # self.next = None class Solution(object): def hasCycle(self, head): &amp;quot;&amp;quot;&amp;quot; :type head: ListNode :rtype: bool &amp;quot;&amp;quot;&amp;quot; slow = head fast = head while fast: if fast and not fast.next: return False fast = fast.</description>
    </item>
    
    <item>
      <title>Compare Version Numbers</title>
      <link>http://www.hashnopolis.com/post/2018/10/compare-version-numbers/</link>
      <pubDate>Tue, 16 Oct 2018 23:26:46 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/10/compare-version-numbers/</guid>
      <description>Compare two version numbers version1 and version2. If version1 &amp;gt; version2 return 1; if version1 &amp;lt; version2 return -1;otherwise return 0.
You may assume that the version strings are non-empty and contain only digits and the . character. The . character does not represent a decimal point and is used to separate number sequences. For instance, 2.5 is not &amp;ldquo;two and a half&amp;rdquo; or &amp;ldquo;half way to version three&amp;rdquo;, it is the fifth second-level revision of the second first-level revision.</description>
    </item>
    
    <item>
      <title>Word Search</title>
      <link>http://www.hashnopolis.com/post/2018/10/word-search/</link>
      <pubDate>Mon, 15 Oct 2018 23:48:28 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/10/word-search/</guid>
      <description>Given a 2D board and a word, find if the word exists in the grid.
The word can be constructed from letters of sequentially adjacent cell, where &amp;ldquo;adjacent&amp;rdquo; cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.
Example:
board = [ [&#39;A&#39;,&#39;B&#39;,&#39;C&#39;,&#39;E&#39;], [&#39;S&#39;,&#39;F&#39;,&#39;C&#39;,&#39;S&#39;], [&#39;A&#39;,&#39;D&#39;,&#39;E&#39;,&#39;E&#39;] ] Given word = &amp;quot;ABCCED&amp;quot;, return true. Given word = &amp;quot;SEE&amp;quot;, return true. Given word = &amp;quot;ABCB&amp;quot;, return false.</description>
    </item>
    
    <item>
      <title>Intersection of Two Linked Lists</title>
      <link>http://www.hashnopolis.com/post/2018/10/intersection-of-two-linked-lists/</link>
      <pubDate>Sun, 14 Oct 2018 23:56:47 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/10/intersection-of-two-linked-lists/</guid>
      <description>Write a program to find the node at which the intersection of two singly linked lists begins.
For example, the following two linked lists:
A: a1 → a2 ↘ c1 → c2 → c3 ↗ B: b1 → b2 → b3  begin to intersect at node c1.
Notes: If the two linked lists have no intersection at all, return null. The linked lists must retain their original structure after the function returns.</description>
    </item>
    
    <item>
      <title>Min Stack</title>
      <link>http://www.hashnopolis.com/post/2018/10/min-stack/</link>
      <pubDate>Sun, 14 Oct 2018 23:55:15 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/10/min-stack/</guid>
      <description>Design a stack that supports push, pop, top, and retrieving the minimum element in constant time. - push(x) &amp;ndash; Push element x onto stack. - pop() &amp;ndash; Removes the element on top of the stack. - top() &amp;ndash; Get the top element. - getMin() &amp;ndash; Retrieve the minimum element in the stack. Example:
MinStack minStack = new MinStack(); minStack.push(-2); minStack.push(0); minStack.push(-3); minStack.getMin(); --&amp;gt; Returns -3. minStack.pop(); minStack.top(); --&amp;gt; Returns 0. minStack.</description>
    </item>
    
    <item>
      <title>Word Break</title>
      <link>http://www.hashnopolis.com/post/2018/10/word-break/</link>
      <pubDate>Wed, 10 Oct 2018 23:57:15 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/10/word-break/</guid>
      <description>Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, determine if s can be segmented into a space-separated sequence of one or more dictionary words.
Note: - The same word in the dictionary may be reused multiple times in the segmentation. - You may assume the dictionary does not contain duplicate words. Example 1:
Input: s = &amp;quot;leetcode&amp;quot;, wordDict = [&amp;quot;leet&amp;quot;, &amp;quot;code&amp;quot;] Output: true Explanation: Return true because &amp;quot;leetcode&amp;quot; can be segmented as &amp;quot;leet code&amp;quot;.</description>
    </item>
    
    <item>
      <title>Number of Islands</title>
      <link>http://www.hashnopolis.com/post/2018/10/number-of-islands/</link>
      <pubDate>Tue, 09 Oct 2018 23:52:32 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/10/number-of-islands/</guid>
      <description>Given a 2d grid map of &#39;1&#39;s (land) and &#39;0&#39;s (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.
Example 1:
Input: 11110 11010 11000 00000 Output: 1  Example 2:
Input: 11000 11000 00100 00011 Output: 3  Solution:
class Solution: def numIslands(self, grid): &amp;quot;&amp;quot;&amp;quot; :type grid: List[List[str]] :rtype: int &amp;quot;&amp;quot;&amp;quot; # Edge cases if not grid or len(grid) == 0 or len(grid[0]) == 0: return 0 rows = len(grid) cols = len(grid[0]) count = 0 for i in range(rows): for j in range(cols): if grid[i][j] == &amp;quot;1&amp;quot;: count += 1 self.</description>
    </item>
    
    <item>
      <title>Binary Tree Maximum Path Sum</title>
      <link>http://www.hashnopolis.com/post/2018/10/binary-tree-maximum-path-sum/</link>
      <pubDate>Tue, 09 Oct 2018 23:50:03 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/10/binary-tree-maximum-path-sum/</guid>
      <description>Given a non-empty binary tree, find the maximum path sum.
For this problem, a path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The path must contain at least one node and does not need to go through the root.
Example 1:
Input: [1,2,3] 1 / \ 2 3 Output: 6  Example 2:
Input: [-10,9,20,null,null,15,7] -10 / \ 9 20 / \ 15 7 Output: 42  Solution:</description>
    </item>
    
    <item>
      <title>Subsets Ii</title>
      <link>http://www.hashnopolis.com/post/2018/10/subsets-ii/</link>
      <pubDate>Mon, 08 Oct 2018 13:04:14 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/10/subsets-ii/</guid>
      <description>Given a collection of integers that might contain duplicates, nums, return all possible subsets (the power set).
Note: The solution set must not contain duplicate subsets.
Example:
Input: [1,2,2] Output: [ [2], [1], [1,2,2], [2,2], [1,2], [] ]  Solution:
# Time: o(2^n) # Space: o(n) class Solution(object): def subsetsWithDup(self, nums): &amp;quot;&amp;quot;&amp;quot; :type nums: List[int] :rtype: List[List[int]] &amp;quot;&amp;quot;&amp;quot; # Edge case if nums == None or len(nums) == 0: return [] # Sort the given numbers nums.</description>
    </item>
    
    <item>
      <title>Merge Sorted Array</title>
      <link>http://www.hashnopolis.com/post/2018/10/merge-sorted-array/</link>
      <pubDate>Mon, 08 Oct 2018 13:03:08 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/10/merge-sorted-array/</guid>
      <description>Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array.
Note: The number of elements initialized in nums1 and nums2 are m and n respectively. You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2. Example:
Input:  nums1 = [1,2,3,0,0,0], m = 3 nums2 = [2,5,6], n = 3</description>
    </item>
    
    <item>
      <title>Decode Ways</title>
      <link>http://www.hashnopolis.com/post/2018/10/decode-ways/</link>
      <pubDate>Wed, 03 Oct 2018 23:49:00 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/10/decode-ways/</guid>
      <description>A message containing letters from A-Z is being encoded to numbers using the following mapping:
&amp;lsquo;A&amp;rsquo; -&amp;gt; 1 &amp;lsquo;B&amp;rsquo; -&amp;gt; 2 &amp;hellip; &amp;lsquo;Z&amp;rsquo; -&amp;gt; 26 Given a non-empty string containing only digits, determine the total number of ways to decode it.
Example 1:
Input: &amp;quot;12&amp;quot; Output: 2 Explanation: It could be decoded as &amp;quot;AB&amp;quot; (1 2) or &amp;quot;L&amp;quot; (12).  Example 2:
Input: &amp;quot;226&amp;quot; Output: 3 Explanation: It could be decoded as &amp;quot;BZ&amp;quot; (2 26), &amp;quot;VF&amp;quot; (22 6), or &amp;quot;BBF&amp;quot; (2 2 6).</description>
    </item>
    
    <item>
      <title>Reverse Linked List</title>
      <link>http://www.hashnopolis.com/post/2018/10/reverse-linked-list/</link>
      <pubDate>Tue, 02 Oct 2018 23:51:13 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/10/reverse-linked-list/</guid>
      <description>Reverse a singly linked list.
Example:
Input: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5-&amp;gt;NULL Output: 5-&amp;gt;4-&amp;gt;3-&amp;gt;2-&amp;gt;1-&amp;gt;NULL  Follow up:
A linked list can be reversed either iteratively or recursively. Could you implement both? Solution:
# Definition for singly-linked list. # class ListNode: # def __init__(self, x): # self.val = x # self.next = None # null 1 ---- 2 ---- 3 ---- 4 ---- 5 # prev curr after # prev curr after # https://www.youtube.com/watch?v=D7y_hoT_YZI class Solution: def reverseList(self, head): &amp;quot;&amp;quot;&amp;quot; :type head: ListNode :rtype: ListNode &amp;quot;&amp;quot;&amp;quot; curr, prev, after = head, None, ListNode(None) while curr !</description>
    </item>
    
    <item>
      <title>Reverse Linked List II</title>
      <link>http://www.hashnopolis.com/post/2018/09/reverse-linked-list-ii/</link>
      <pubDate>Sun, 30 Sep 2018 22:19:41 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/09/reverse-linked-list-ii/</guid>
      <description>Reverse a linked list from position m to n. Do it in one-pass.
Note: 1 ≤ m ≤ n ≤ length of list.
Example:
Input: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5-&amp;gt;NULL, m = 2, n = 4 Output: 1-&amp;gt;4-&amp;gt;3-&amp;gt;2-&amp;gt;5-&amp;gt;NULL  *Solution:**
class Solution: def reverseBetween(self, head, m, n): &amp;quot;&amp;quot;&amp;quot; :type head: ListNode :type m: int :type n: int :rtype: ListNode &amp;quot;&amp;quot;&amp;quot; dummy = ListNode(None) dummy.next = head pre = dummy curr = dummy.next for i in range(1, m): curr = curr.</description>
    </item>
    
    <item>
      <title>Gray Code</title>
      <link>http://www.hashnopolis.com/post/2018/09/gray-code/</link>
      <pubDate>Tue, 25 Sep 2018 08:14:01 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/09/gray-code/</guid>
      <description>The gray code is a binary numeral system where two successive values differ in only one bit.
Given a non-negative integer n representing the total number of bits in the code, print the sequence of gray code. A gray code sequence must begin with 0.
For example, given n = 2, return [0,1,3,2]. Its gray code sequence is:
00 - 0 01 - 1 11 - 3 10 - 2  Note: For a given n, a gray code sequence is not uniquely defined.</description>
    </item>
    
    <item>
      <title>Add Digits</title>
      <link>http://www.hashnopolis.com/post/2018/09/add-digits/</link>
      <pubDate>Sun, 23 Sep 2018 23:18:25 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/09/add-digits/</guid>
      <description>Given a non-negative integer num, repeatedly add all its digits until the result has only one digit.
For example:
Given num = 38, the process is like: 3 + 8 = 11, 1 + 1 = 2. Since 2 has only one digit, return it.
Follow up: Could you do it without any loop/recursion in O(1) runtime?
Credits: Special thanks to @jianchao.li.fighter for adding this problem and creating all test cases.</description>
    </item>
    
    <item>
      <title>Remove Duplicates From Sorted List II</title>
      <link>http://www.hashnopolis.com/post/2018/09/remove-duplicates-from-sorted-list-ii/</link>
      <pubDate>Wed, 19 Sep 2018 10:38:38 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/09/remove-duplicates-from-sorted-list-ii/</guid>
      <description>Given a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list.
Example 1:
Input: 1-&amp;gt;2-&amp;gt;3-&amp;gt;3-&amp;gt;4-&amp;gt;4-&amp;gt;5 Output: 1-&amp;gt;2-&amp;gt;5  Example 2:
Input: 1-&amp;gt;1-&amp;gt;1-&amp;gt;2-&amp;gt;3 Output: 2-&amp;gt;3  </description>
    </item>
    
    <item>
      <title>Remove Linked List Elements</title>
      <link>http://www.hashnopolis.com/post/2018/09/remove-linked-list-elements/</link>
      <pubDate>Tue, 18 Sep 2018 16:07:09 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/09/remove-linked-list-elements/</guid>
      <description>Remove all elements from a linked list of integers that have value val.
Example:
Input: 1-&amp;gt;2-&amp;gt;6-&amp;gt;3-&amp;gt;4-&amp;gt;5-&amp;gt;6, val = 6 Output: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5  Solution:
# Definition for singly-linked list. # class ListNode: # def __init__(self, x): # self.val = x # self.next = None class Solution: def removeElements(self, head, val): &amp;quot;&amp;quot;&amp;quot; :type head: ListNode :type val: int :rtype: ListNode &amp;quot;&amp;quot;&amp;quot; pre = ListNode(0) pre.next = head pos = pre while pos.next !</description>
    </item>
    
    <item>
      <title>Unique Binary Search Trees</title>
      <link>http://www.hashnopolis.com/post/2018/09/unique-binary-search-trees/</link>
      <pubDate>Sun, 16 Sep 2018 15:06:01 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/09/unique-binary-search-trees/</guid>
      <description>Given n, how many structurally unique BST&amp;rsquo;s (binary search trees) that store values 1 &amp;hellip; n?
Example:
Input: 3 Output: 5 Explanation: Given n = 3, there are a total of 5 unique BST&#39;s: 1 3 3 2 1 \ / / / \ \ 3 2 1 1 3 2 / / \ \ 2 1 2 3  Exaplanation:
n = 3 root: 1 left: 0 right: 2 f(0)*f(2); root: 2 left: 1 right: 1 f(1)*f(1); root: 3 left: 2 right: 0 f(2)*f(0);  Solution:</description>
    </item>
    
    <item>
      <title>Symmetric Tree</title>
      <link>http://www.hashnopolis.com/post/2018/09/symmetric-tree/</link>
      <pubDate>Sun, 16 Sep 2018 15:05:12 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/09/symmetric-tree/</guid>
      <description>Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).
For example, this binary tree [1,2,2,3,4,4,3] is symmetric:
 1 / \ 2 2 / \ / \ 3 4 4 3  But the following [1,2,2,null,3,null,3] is not:
 1 / \ 2 2 \ \ 3 3  Note: Bonus points if you could solve it both recursively and iteratively.
Solution:</description>
    </item>
    
    <item>
      <title>Top K Frequent Elements</title>
      <link>http://www.hashnopolis.com/post/2018/09/top-k-frequent-elements/</link>
      <pubDate>Sun, 16 Sep 2018 15:04:30 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/09/top-k-frequent-elements/</guid>
      <description>Given a non-empty array of integers, return the k most frequent elements.
For example, Given [1,1,1,2,2,3] and k = 2, return [1,2]. Note: You may assume k is always valid, 1 ≤ k ≤ number of unique elements. Your algorithm&amp;rsquo;s time complexity must be better than O(n log n), where n is the array&amp;rsquo;s size. Solution:
class Solution: def topKFrequent(self, nums, k): &amp;quot;&amp;quot;&amp;quot; :type nums: List[int] :type k: int :rtype: List[int] &amp;quot;&amp;quot;&amp;quot; freqMap = dict() for num in nums: if freqMap.</description>
    </item>
    
    <item>
      <title>Same Tree</title>
      <link>http://www.hashnopolis.com/post/2018/09/same-tree/</link>
      <pubDate>Sun, 16 Sep 2018 15:03:53 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/09/same-tree/</guid>
      <description>Given two binary trees, write a function to check if they are the same or not.
Two binary trees are considered the same if they are structurally identical and the nodes have the same value.
Example 1:
Input: 1 1 / \ / \ 2 3 2 3 [1,2,3], [1,2,3] Output: true  Example 2:
Input: 1 1 / \ 2 2 [1,2], [1,null,2] Output: false  Example 3:
Input: 1 1 / \ / \ 2 1 1 2 [1,2,1], [1,1,2] Output: false  Solution</description>
    </item>
    
    <item>
      <title>Remove Element</title>
      <link>http://www.hashnopolis.com/post/2018/09/remove-element/</link>
      <pubDate>Sun, 16 Sep 2018 15:02:20 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/09/remove-element/</guid>
      <description>Given an array nums and a value val, remove all instances of that value in-place and return the new length.
Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.
The order of elements can be changed. It doesn&amp;rsquo;t matter what you leave beyond the new length.
Example 1:
Given nums = [3,2,2,3], val = 3, Your function should return length = 2, with the first two elements of nums being 2.</description>
    </item>
    
    <item>
      <title>Remove Duplicates From Sorted List</title>
      <link>http://www.hashnopolis.com/post/2018/09/remove-duplicates-from-sorted-list/</link>
      <pubDate>Sun, 16 Sep 2018 15:01:24 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/09/remove-duplicates-from-sorted-list/</guid>
      <description>Given a sorted linked list, delete all duplicates such that each element appear only once.
Example 1:
Input: 1-&amp;gt;1-&amp;gt;2 Output: 1-&amp;gt;2  Example 2:
Input: 1-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;3 Output: 1-&amp;gt;2-&amp;gt;3  Solution:
# Definition for singly-linked list. # class ListNode(object): # def __init__(self, x): # self.val = x # self.next = None class Solution(object): def deleteDuplicates(self, head): &amp;quot;&amp;quot;&amp;quot; :type head: ListNode :rtype: ListNode &amp;quot;&amp;quot;&amp;quot; curr = head while curr != None and curr.</description>
    </item>
    
    <item>
      <title>Power of Two</title>
      <link>http://www.hashnopolis.com/post/2018/09/power-of-two/</link>
      <pubDate>Sat, 15 Sep 2018 12:56:41 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/09/power-of-two/</guid>
      <description>Given an integer, write a function to determine if it is a power of two.
Example 1:
Input: 1 Output: true Explanation: 2**0 = 1  Example 2:
Input: 16 Output: true Explanation: 2**4 = 16  Example 3:
Input: 218 Output: false  Solution:
class Solution: def isPowerOfTwo(self, n): &amp;quot;&amp;quot;&amp;quot; :type n: int :rtype: bool &amp;quot;&amp;quot;&amp;quot; if n == 0: return False if n &amp;amp; (n - 1) == 0: return True return False  </description>
    </item>
    
    <item>
      <title>Plus One</title>
      <link>http://www.hashnopolis.com/post/2018/09/plus-one/</link>
      <pubDate>Sat, 15 Sep 2018 12:56:08 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/09/plus-one/</guid>
      <description>Given a non-empty array of digits representing a non-negative integer, plus one to the integer.
The digits are stored such that the most significant digit is at the head of the list, and each element in the array contain a single digit.
You may assume the integer does not contain any leading zero, except the number 0 itself.
Example 1:
Input: [1,2,3] Output: [1,2,4] Explanation: The array represents the integer 123.</description>
    </item>
    
    <item>
      <title>Swap Nodes in Pairs</title>
      <link>http://www.hashnopolis.com/post/2018/09/swap-nodes-in-pairs/</link>
      <pubDate>Sat, 15 Sep 2018 12:55:20 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/09/swap-nodes-in-pairs/</guid>
      <description>Given a linked list, swap every two adjacent nodes and return its head.
Example:
Given 1-&amp;gt;2-&amp;gt;3-&amp;gt;4, you should return the list as 2-&amp;gt;1-&amp;gt;4-&amp;gt;3.  Note: - Your algorithm should use only constant extra space. - You may not modify the values in the list&amp;rsquo;s nodes, only nodes itself may be changed. Solution:
# Definition for singly-linked list. # class ListNode(object): # def __init__(self, x): # self.val = x # self.next = None class Solution(object): def swapPairs(self, head): &amp;quot;&amp;quot;&amp;quot; :type head: ListNode :rtype: ListNode &amp;quot;&amp;quot;&amp;quot; # https://www.</description>
    </item>
    
    <item>
      <title>Unique Paths</title>
      <link>http://www.hashnopolis.com/post/2018/09/unique-paths/</link>
      <pubDate>Sat, 15 Sep 2018 12:54:17 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/09/unique-paths/</guid>
      <description>A robot is located at the top-left corner of a m x n grid (marked &amp;lsquo;Start&amp;rsquo; in the diagram below).
The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked &amp;lsquo;Finish&amp;rsquo; in the diagram below).
How many possible unique paths are there?
Above is a 7 x 3 grid. How many possible unique paths are there?</description>
    </item>
    
    <item>
      <title>Valid Anagram</title>
      <link>http://www.hashnopolis.com/post/2018/09/valid-anagram/</link>
      <pubDate>Sat, 15 Sep 2018 12:53:21 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/09/valid-anagram/</guid>
      <description>Given two strings s and t , write a function to determine if t is an anagram of s.
Example 1:
Input: s = &amp;quot;anagram&amp;quot;, t = &amp;quot;nagaram&amp;quot; Output: true  Example 2:
Input: s = &amp;quot;rat&amp;quot;, t = &amp;quot;car&amp;quot; Output: false  Note: You may assume the string contains only lowercase alphabets.
Follow up: What if the inputs contain unicode characters? How would you adapt your solution to such case?</description>
    </item>
    
    <item>
      <title>Ugly Number</title>
      <link>http://www.hashnopolis.com/post/2018/09/ugly-number/</link>
      <pubDate>Sat, 15 Sep 2018 12:52:53 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/09/ugly-number/</guid>
      <description>Write a program to check whether a given number is an ugly number.
Ugly numbers are positive numbers whose prime factors only include 2, 3, 5.
Example 1:
Input: 6 Output: true Explanation: 6 = 2 × 3  Example 2:
Input: 8 Output: true Explanation: 8 = 2 × 2 × 2  Example 3:
Input: 14 Output: false Explanation: 14 is not ugly since it includes another prime factor 7.</description>
    </item>
    
    <item>
      <title>Subsets</title>
      <link>http://www.hashnopolis.com/post/2018/09/subsets/</link>
      <pubDate>Sat, 15 Sep 2018 12:48:42 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/09/subsets/</guid>
      <description>Given a set of distinct integers, nums, return all possible subsets (the power set).
Note: The solution set must not contain duplicate subsets.
Example:
Input: nums = [1,2,3] Output: [ [3], [1], [2], [1,2,3], [1,3], [2,3], [1,2], [] ]  Solution:
# Time: o(2^n) # Space: o(n) class Solution: def subsets(self, nums): &amp;quot;&amp;quot;&amp;quot; :type nums: List[int] :rtype: List[List[int]] &amp;quot;&amp;quot;&amp;quot; res = [] def dfs(nums, index, path): res.append(path) for i in range(index, len(nums)): dfs(nums, i+1, path+[nums[i]]) dfs(sorted(nums), 0, []) return res # or class Solution(object): def subsets(self, nums): &amp;quot;&amp;quot;&amp;quot; :type nums: List[int] :rtype: List[List[int]] &amp;quot;&amp;quot;&amp;quot; # Edge case if nums == None or len(nums) == 0: return [] # Sort the given numbers nums.</description>
    </item>
    
    <item>
      <title>Roman to Integer</title>
      <link>http://www.hashnopolis.com/post/2018/09/roman-to-integer/</link>
      <pubDate>Sat, 15 Sep 2018 12:47:14 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/09/roman-to-integer/</guid>
      <description>Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.
Symbol Value I 1 V 5 X 10 L 50 C 100 D 500 M 1000  For example, two is written as II in Roman numeral, just two one&amp;rsquo;s added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II.</description>
    </item>
    
    <item>
      <title>Single Number III</title>
      <link>http://www.hashnopolis.com/post/2018/09/single-number-iii/</link>
      <pubDate>Fri, 14 Sep 2018 11:54:43 +0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/09/single-number-iii/</guid>
      <description>Given an array of numbers nums, in which exactly two elements appear only once and all the other elements appear exactly twice. Find the two elements that appear only once.
For example: Given nums = [1, 2, 1, 3, 2, 5], return [3, 5]. Note:
 The order of the result is not important. So in the above example, [5, 3] is also correct. Your algorithm should run in linear runtime complexity.</description>
    </item>
    
    <item>
      <title>Single Number II</title>
      <link>http://www.hashnopolis.com/post/2018/09/single-number-ii/</link>
      <pubDate>Fri, 14 Sep 2018 11:53:51 +0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/09/single-number-ii/</guid>
      <description>Given a non-empty array of integers, every element appears three times except for one, which appears exactly once. Find that single one.
Note:
Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?
Example 1:
Input: [2,2,3,2] Output: 3  Example 2:
Input: [0,1,0,1,0,1,99] Output: 99  Solution:
class Solution: def singleNumber(self, nums): &amp;quot;&amp;quot;&amp;quot; :type nums: List[int] :rtype: int &amp;quot;&amp;quot;&amp;quot; # https://www.cnblogs.com/ganganloveu/p/4110996.html # https://blog.csdn.net/karen0310/article/details/78226261 ones, twos = 0, 0 for _, num in enumerate(nums): ones = (ones ^ num) &amp;amp; ~twos twos = (twos ^ num) &amp;amp; ~ones print(bin(num), &amp;quot;ones: &amp;quot;, bin(ones), &amp;quot;twos: &amp;quot;, bin(twos)) return ones  </description>
    </item>
    
    <item>
      <title>Single Number</title>
      <link>http://www.hashnopolis.com/post/2018/09/single-number/</link>
      <pubDate>Fri, 14 Sep 2018 11:53:00 +0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/09/single-number/</guid>
      <description> Given a non-empty array of integers, every element appears twice except for one. Find that single one. Note: Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?
Example 1:
Input: [2,2,1] Output: 1 Example 2:  Input: [4,1,2,1,2] Output: 4  Solution:
// Java class Solution { public int singleNumber(int[] nums) { int result=0; for(int num : nums) { result=result^num; } return result; } }  </description>
    </item>
    
    <item>
      <title>Find Peak Element</title>
      <link>http://www.hashnopolis.com/post/2018/09/find-peak-element/</link>
      <pubDate>Fri, 14 Sep 2018 11:51:46 +0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/09/find-peak-element/</guid>
      <description>A peak element is an element that is greater than its neighbors.
Given an input array nums, where nums[i] ≠ nums[i+1], find a peak element and return its index.
The array may contain multiple peaks, in that case return the index to any one of the peaks is fine.
You may imagine that nums[-1] = nums[n] = -∞.
Example 1:
Input: nums = [1,2,3,1] Output: 2 Explanation: 3 is a peak element and your function should return the index number 2.</description>
    </item>
    
    <item>
      <title>Find Minimum in Rotated Sorted Array</title>
      <link>http://www.hashnopolis.com/post/2018/09/find-minimum-in-rotated-sorted-array/</link>
      <pubDate>Fri, 14 Sep 2018 11:50:46 +0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/09/find-minimum-in-rotated-sorted-array/</guid>
      <description>Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.
(i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]).
Find the minimum element.
You may assume no duplicate exists in the array.
Example 1:
Input: [3,4,5,1,2] Output: 1  Example 2:
Input: [4,5,6,7,0,1,2] Output: 0  Solution:
class Solution: def findMin(self, nums): &amp;quot;&amp;quot;&amp;quot; :type nums: List[int] :rtype: int &amp;quot;&amp;quot;&amp;quot; if len(nums) == 1: return nums[0] if len(nums) == 2: return min(nums[0], nums[1]) if nums[0] &amp;lt; nums[len(nums)-1]: return nums[0] if nums[len(nums)-2] &amp;gt; nums[len(nums)-1]: return nums[len(nums)-1] for i in range(1, len(nums)-1): if nums[i] &amp;lt; nums[i-1] and nums[i] &amp;lt; nums[i+1]: return nums[i] def bsFindMin(self, nums): l, r = 0, len(nums) - 1 while l &amp;lt; r: m = (l + r) // 2 if nums[m] &amp;gt; nums[m - 1] and nums[m] &amp;gt; nums[m + 1]: return nums[m + 1] if nums[m] &amp;lt; nums[m - 1] and nums[m] &amp;lt; nums[m + 1]: return nums[m] if nums[m] &amp;gt;= nums[r]: l = m else: r = m return nums[0]  </description>
    </item>
    
    <item>
      <title>Delete Node in a Linked List</title>
      <link>http://www.hashnopolis.com/post/2018/09/delete-node-in-a-linked-list/</link>
      <pubDate>Fri, 14 Sep 2018 11:49:07 +0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/09/delete-node-in-a-linked-list/</guid>
      <description>Write a function to delete a node (except the tail) in a singly linked list, given only access to that node.
Supposed the linked list is 1 -&amp;gt; 2 -&amp;gt; 3 -&amp;gt; 4 and you are given the third node with value 3, the linked list should become 1 -&amp;gt; 2 -&amp;gt; 4 after calling your function.
Solution:
# Definition for singly-linked list. # class ListNode(object): # def __init__(self, x): # self.</description>
    </item>
    
    <item>
      <title>Convert Sorted Array to Binary Search Tree</title>
      <link>http://www.hashnopolis.com/post/2018/09/convert-sorted-array-to-binary-search-tree/</link>
      <pubDate>Fri, 14 Sep 2018 10:23:36 +0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/09/convert-sorted-array-to-binary-search-tree/</guid>
      <description>Given an array where elements are sorted in ascending order, convert it to a height balanced BST.
For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.
Example:
Given the sorted array: [-10,-3,0,5,9], One possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST: 0 / \ -3 9 / / -10 5  Solution:</description>
    </item>
    
    <item>
      <title>Binary Tree Right Side View</title>
      <link>http://www.hashnopolis.com/post/2018/09/binary-tree-right-side-view/</link>
      <pubDate>Thu, 13 Sep 2018 23:03:06 +0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/09/binary-tree-right-side-view/</guid>
      <description>Given a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom.
Example:
Input: [1,2,3,null,5,null,4] Output: [1, 3, 4] Explanation: 1 &amp;lt;--- / \ 2 3 &amp;lt;--- \ \ 5 4 &amp;lt;---  Solution:
# Definition for a binary tree node. # class TreeNode: # def __init__(self, x): # self.val = x # self.left = None # self.</description>
    </item>
    
    <item>
      <title>Binary Tree Preorder Traversal</title>
      <link>http://www.hashnopolis.com/post/2018/09/binary-tree-preorder-traversal/</link>
      <pubDate>Thu, 13 Sep 2018 23:02:11 +0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/09/binary-tree-preorder-traversal/</guid>
      <description>Given a binary tree, return the preorder traversal of its nodes&amp;rsquo; values.
Example:
Input: [1,null,2,3] 1 \ 2 / 3 Output: [1,2,3]  Follow up: Recursive solution is trivial, could you do it iteratively?
Solution:
# Definition for a binary tree node. # class TreeNode(object): # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution(object): def preorderTraversal_1(self, root): &amp;quot;&amp;quot;&amp;quot; :type root: TreeNode :rtype: List[int] &amp;quot;&amp;quot;&amp;quot; if root is None: return [] return [root.</description>
    </item>
    
    <item>
      <title>Binary Tree Postorder Traversal</title>
      <link>http://www.hashnopolis.com/post/2018/09/binary-tree-postorder-traversal/</link>
      <pubDate>Thu, 13 Sep 2018 23:01:30 +0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/09/binary-tree-postorder-traversal/</guid>
      <description>Given a binary tree, return the postorder traversal of its nodes&amp;rsquo; values.
Example:
Input: [1,null,2,3] 1 \ 2 / 3 Output: [3,2,1]  Follow up:
Recursive solution is trivial, could you do it iteratively?
Solution:
Recursive👇
# Definition for a binary tree node. # class TreeNode: # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution: def postorderTraversal(self, root): &amp;quot;&amp;quot;&amp;quot; :type root: TreeNode :rtype: List[int] &amp;quot;&amp;quot;&amp;quot; def traverse(node): if node == None: return [] return traverse(node.</description>
    </item>
    
    <item>
      <title>Binary Tree Paths</title>
      <link>http://www.hashnopolis.com/post/2018/09/binary-tree-paths/</link>
      <pubDate>Thu, 13 Sep 2018 23:00:42 +0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/09/binary-tree-paths/</guid>
      <description>Given a binary tree, return all root-to-leaf paths.
Note: A leaf is a node with no children.
Example:
Input: 1 / \ 2 3 \ 5 Output: [&amp;quot;1-&amp;gt;2-&amp;gt;5&amp;quot;, &amp;quot;1-&amp;gt;3&amp;quot;]  Explanation: All root-to-leaf paths are: 1-&amp;gt;2-&amp;gt;5, 1-&amp;gt;3
Solution:
# Definition for a binary tree node. # class TreeNode: # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution: def binaryTreePaths(self, root): &amp;quot;&amp;quot;&amp;quot; :type root: TreeNode :rtype: List[str] &amp;quot;&amp;quot;&amp;quot; res = [] def traverse(root, path): if root == None: return path += str(root.</description>
    </item>
    
    <item>
      <title>Binary Tree Level Order Traversal</title>
      <link>http://www.hashnopolis.com/post/2018/09/binary-tree-level-order-traversal/</link>
      <pubDate>Thu, 13 Sep 2018 22:59:49 +0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/09/binary-tree-level-order-traversal/</guid>
      <description>Given a binary tree, return the level order traversal of its nodes&amp;rsquo; values. (ie, from left to right, level by level).
For example:
Given binary tree `[3,9,20,null,null,15,7]`, 3 / \ 9 20 / \ 15 7  return its level order traversal as:
[ [3], [9,20], [15,7] ]  Solution:
# Definition for a binary tree node. # class TreeNode: # def __init__(self, x): # self.val = x # self.left = None # self.</description>
    </item>
    
    <item>
      <title>Binary Tree Level Order Traversal II</title>
      <link>http://www.hashnopolis.com/post/2018/09/binary-tree-level-order-traversal-ii/</link>
      <pubDate>Thu, 13 Sep 2018 22:59:17 +0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/09/binary-tree-level-order-traversal-ii/</guid>
      <description>Given a binary tree, return the bottom-up level order traversal of its nodes&amp;rsquo; values. (ie, from left to right, level by level from leaf to root).
For example: Given binary tree [3,9,20,null,null,15,7],
 3 / \ 9 20 / \ 15 7  return its bottom-up level order traversal as:
[ [15,7], [9,20], [3] ]  Solution:
# Definition for a binary tree node. # class TreeNode: # def __init__(self, x): # self.</description>
    </item>
    
    <item>
      <title>Binary Tree Inorder Traversal</title>
      <link>http://www.hashnopolis.com/post/2018/09/binary-tree-inorder-traversal/</link>
      <pubDate>Thu, 13 Sep 2018 22:57:42 +0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/09/binary-tree-inorder-traversal/</guid>
      <description>Given a binary tree, return the inorder traversal of its nodes&amp;rsquo; values.
Example:
Input: [1,null,2,3] 1 \ 2 / 3 Output: [1,3,2]  Follow up: the Recursive solution is trivial, could you do it iteratively?
Solution
# Definition for a binary tree node. # class TreeNode: # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution: def inorderTraversal(self, root): &amp;quot;&amp;quot;&amp;quot; :type root: TreeNode :rtype: List[int] &amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot;Check root == None to reduce time on checking&amp;quot;&amp;quot;&amp;quot; if root == None: return [] stack = [] result = [] current = root while (current!</description>
    </item>
    
    <item>
      <title>Combination Sum III</title>
      <link>http://www.hashnopolis.com/post/2018/09/combination-sum-iii/</link>
      <pubDate>Mon, 10 Sep 2018 21:42:37 +0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/09/combination-sum-iii/</guid>
      <description>Find all possible combinations of k numbers that add up to a number n, given that only numbers from 1 to 9 can be used and each combination should be a unique set of numbers.
Note:
All numbers will be positive integers. The solution set must not contain duplicate combinations. Example 1:
Input: k = 3, n = 7 Output: [[1,2,4]]  Example 2:
Input: k = 3, n = 9 Output: [[1,2,6], [1,3,5], [2,3,4]]  Solution:</description>
    </item>
    
    <item>
      <title>Combination Sum</title>
      <link>http://www.hashnopolis.com/post/2018/09/combination-sum/</link>
      <pubDate>Mon, 10 Sep 2018 21:42:01 +0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/09/combination-sum/</guid>
      <description>Given a set of candidate numbers (candidates) (without duplicates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target.
The same repeated number may be chosen from candidates unlimited number of times.
Note:
All numbers (including target) will be positive integers. The solution set must not contain duplicate combinations. Example 1:
Input: candidates = [2,3,6,7], target = 7, A solution set is: [ [7], [2,2,3] ]  Example 2:</description>
    </item>
    
    <item>
      <title>Combinations</title>
      <link>http://www.hashnopolis.com/post/2018/09/combinations/</link>
      <pubDate>Mon, 10 Sep 2018 21:41:18 +0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/09/combinations/</guid>
      <description>Given two integers n and k, return all possible combinations of k numbers out of 1 ... n.
Example:
Input: n = 4, k = 2 Output: [ [2,4], [3,4], [2,3], [1,2], [1,3], [1,4], ]  Solution:
class Solution: def combine(self, n, k): &amp;quot;&amp;quot;&amp;quot; :type n: int :type k: int :rtype: List[List[int]] &amp;quot;&amp;quot;&amp;quot; res = [] nums = list(range(1, n+1)) def iterate(index, tempAns): ans = list(tempAns) if len(ans) &amp;gt; k: return if index &amp;lt; n: ans.</description>
    </item>
    
    <item>
      <title>Combine Two Tables</title>
      <link>http://www.hashnopolis.com/post/2018/09/combine-two-tables/</link>
      <pubDate>Mon, 10 Sep 2018 21:40:30 +0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/09/combine-two-tables/</guid>
      <description>Table: Person
+-------------+---------+ | Column Name | Type | +-------------+---------+ | PersonId | int | | FirstName | varchar | | LastName | varchar | +-------------+---------+ PersonId is the primary key column for this table.  Table: Address
+-------------+---------+ | Column Name | Type | +-------------+---------+ | AddressId | int | | PersonId | int | | City | varchar | | State | varchar | +-------------+---------+ AddressId is the primary key column for this table.</description>
    </item>
    
    <item>
      <title>Contains Duplicate</title>
      <link>http://www.hashnopolis.com/post/2018/09/contains-duplicate/</link>
      <pubDate>Mon, 10 Sep 2018 21:39:18 +0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/09/contains-duplicate/</guid>
      <description>Given an array of integers, find if the array contains any duplicates.
Your function should return true if any value appears at least twice in the array, and it should return false if every element is distinct.
Example 1:
Input: [1,2,3,1] Output: true  Example 2:
Input: [1,2,3,4] Output: false  Example 3:
Input: [1,1,1,3,3,4,3,2,4,2] Output: true  Solution:
class Solution: def containsDuplicate(self, nums): &amp;quot;&amp;quot;&amp;quot; :type nums: List[int] :rtype: bool &amp;quot;&amp;quot;&amp;quot; sortedNums = sorted(nums) for i in range(1, len(nums)): if sortedNums[i] == sortedNums[i-1]: return True return False  </description>
    </item>
    
    <item>
      <title>Climbing Stairs</title>
      <link>http://www.hashnopolis.com/post/2018/09/climbing-stairs/</link>
      <pubDate>Sun, 09 Sep 2018 15:16:10 +0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/09/climbing-stairs/</guid>
      <description>You are climbing a stair case. It takes n steps to reach to the top.
Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?
Note: Given n will be a positive integer.
Example 1:
Input: 2 Output: 2 Explanation: There are two ways to climb to the top. 1. 1 step + 1 step 2. 2 steps  Example 2:</description>
    </item>
    
    <item>
      <title>Binary Search Tree Iterator</title>
      <link>http://www.hashnopolis.com/post/2018/09/binary-search-tree-iterator/</link>
      <pubDate>Sun, 09 Sep 2018 15:15:09 +0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/09/binary-search-tree-iterator/</guid>
      <description>Implement an iterator over a binary search tree (BST). Your iterator will be initialized with the root node of a BST.
Calling next() will return the next smallest number in the BST.
Note: next() and hasNext() should run in average O(1) time and uses O(h) memory, where h is the height of the tree.
Solution:
# Definition for a binary tree node # class TreeNode(object): # def __init__(self, x): # self.</description>
    </item>
    
    <item>
      <title>Two Sum II Input Array Is Sorted</title>
      <link>http://www.hashnopolis.com/post/2018/09/two-sum-ii-input-array-is-sorted/</link>
      <pubDate>Fri, 07 Sep 2018 23:53:18 +0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/09/two-sum-ii-input-array-is-sorted/</guid>
      <description>Given an array of integers that is already sorted in ascending order, find two numbers such that they add up to a specific target number.
The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2.
Note: - Your returned answers (both index1 and index2) are not zero-based. - You may assume that each input would have exactly one solution and you may not use the same element twice.</description>
    </item>
    
    <item>
      <title>Best Time to Buy and Sell Stock Ii</title>
      <link>http://www.hashnopolis.com/post/2018/09/best-time-to-buy-and-sell-stock-ii/</link>
      <pubDate>Thu, 06 Sep 2018 23:39:13 +0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/09/best-time-to-buy-and-sell-stock-ii/</guid>
      <description>Say you have an array for which the ith element is the price of a given stock on day i.
Design an algorithm to find the maximum profit. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times).
Note: You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again).</description>
    </item>
    
    <item>
      <title>Best Time to Buy and Sell Stock</title>
      <link>http://www.hashnopolis.com/post/2018/09/best-time-to-buy-and-sell-stock/</link>
      <pubDate>Thu, 06 Sep 2018 23:37:49 +0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/09/best-time-to-buy-and-sell-stock/</guid>
      <description>Say you have an array for which the ith element is the price of a given stock on day i.
If you were only permitted to complete at most one transaction (i.e., buy one and sell one share of the stock), design an algorithm to find the maximum profit.
Note that you cannot sell a stock before you buy one.
Example 1:
Input: [7,1,5,3,6,4] Output: 5 Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.</description>
    </item>
    
    <item>
      <title>Add Binary</title>
      <link>http://www.hashnopolis.com/post/2018/09/add-binary/</link>
      <pubDate>Wed, 05 Sep 2018 23:48:48 +0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/09/add-binary/</guid>
      <description>Given two binary strings, return their sum (also a binary string).
The input strings are both non-empty and contains only characters 1 or 0.
Example 1:
Input: a = &amp;quot;11&amp;quot;, b = &amp;quot;1&amp;quot; Output: &amp;quot;100&amp;quot;  Example 2:
Input: a = &amp;quot;1010&amp;quot;, b = &amp;quot;1011&amp;quot; Output: &amp;quot;10101&amp;quot;  Solution:
class Solution: def addBinary(self, a, b): &amp;quot;&amp;quot;&amp;quot; :type a: str :type b: str :rtype: str &amp;quot;&amp;quot;&amp;quot; result = [] carry = 0 i = len(a)-1 j = len(b)-1 while carry or i &amp;gt;= 0 or j &amp;gt;= 0: total = carry if i &amp;gt;= 0: total += int(a[i]) i -= 1 if j &amp;gt;= 0: total += int(b[j]) j -= 1 result.</description>
    </item>
    
    <item>
      <title>17. Letter Combinations of a Phone Number</title>
      <link>http://www.hashnopolis.com/post/2018/09/17.-letter-combinations-of-a-phone-number/</link>
      <pubDate>Mon, 03 Sep 2018 00:28:45 +0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/09/17.-letter-combinations-of-a-phone-number/</guid>
      <description>Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent.
A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.
Example:
Input: &amp;quot;23&amp;quot; Output: [&amp;quot;ad&amp;quot;, &amp;quot;ae&amp;quot;, &amp;quot;af&amp;quot;, &amp;quot;bd&amp;quot;, &amp;quot;be&amp;quot;, &amp;quot;bf&amp;quot;, &amp;quot;cd&amp;quot;, &amp;quot;ce&amp;quot;, &amp;quot;cf&amp;quot;].  Note:
Although the above answer is in lexicographical order, your answer could be in any order you want.</description>
    </item>
    
    <item>
      <title>18. 4Sum</title>
      <link>http://www.hashnopolis.com/post/2018/08/18.-4sum/</link>
      <pubDate>Fri, 31 Aug 2018 23:30:43 +0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/08/18.-4sum/</guid>
      <description>Given an array nums of n integers and an integer target, are there elements a, b, c, and d in nums such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target.
Note:
The solution set must not contain duplicate quadruplets.
Example:
Given array nums = [1, 0, -1, 0, -2, 2], and target = 0. A solution set is: [ [-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2] ]  </description>
    </item>
    
    <item>
      <title>Two Sum</title>
      <link>http://www.hashnopolis.com/post/2018/08/two-sum/</link>
      <pubDate>Wed, 29 Aug 2018 00:44:49 +0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/08/two-sum/</guid>
      <description>Given an array of integers, return indices of the two numbers such that they add up to a specific target.
You may assume that each input would have exactly one solution, and you may not use the same element twice.
Example:
Given nums = [2, 7, 11, 15], target = 9, Because nums[0] + nums[1] = 2 + 7 = 9, return [0, 1].  Solution:
# time: o(n) # space: o(n) class Solution: def twoSum(self, nums, target): &amp;quot;&amp;quot;&amp;quot; :type nums: List[int] :type target: int :rtype: List[int] &amp;quot;&amp;quot;&amp;quot; res = [-1, -1] if nums == None or len(nums) &amp;lt; 2: return res solutionMap = {} for pos in range(len(nums) - 1): if (target - nums[pos]) in solutionMap: res[0] = solutionMap[target - nums[pos]] res[1] = pos break solutionMap[nums[pos]] = pos return res  </description>
    </item>
    
    <item>
      <title>16. 3sum Closest</title>
      <link>http://www.hashnopolis.com/post/2018/08/16.-3sum-closest/</link>
      <pubDate>Mon, 27 Aug 2018 23:30:43 +0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/08/16.-3sum-closest/</guid>
      <description>Given an array nums of n integers and an integer target, find three integers in nums such that the sum is closest to target. Return the sum of the three integers. You may assume that each input would have exactly one solution.
Example:
Given array nums = [-1, 2, 1, -4], and target = 1. The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).</description>
    </item>
    
    <item>
      <title>15. 3sum</title>
      <link>http://www.hashnopolis.com/post/2018/08/15.-3sum/</link>
      <pubDate>Mon, 27 Aug 2018 23:29:18 +0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/08/15.-3sum/</guid>
      <description>Given an array nums of n integers, are there elements a, b, c in nums such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.
Note:
The solution set must not contain duplicate triplets.
Example:
Given array nums = [-1, 0, 1, 2, -1, -4], A solution set is: [ [-1, 0, 1], [-1, -1, 2] ]  Solution:</description>
    </item>
    
    <item>
      <title>57. Insert Interval</title>
      <link>http://www.hashnopolis.com/post/2018/08/57.-insert-interval/</link>
      <pubDate>Sun, 26 Aug 2018 00:43:48 +0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/08/57.-insert-interval/</guid>
      <description>Given a set of non-overlapping intervals, insert a new interval into the intervals (merge if necessary).
You may assume that the intervals were initially sorted according to their start times.
Example 1:
Input: intervals = [[1,3],[6,9]], newInterval = [2,5] Output: [[1,5],[6,9]]  Example 2:
Input: intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8] Output: [[1,2],[3,10],[12,16]] Explanation: Because the new interval [4,8] overlaps with [3,5],[6,7],[8,10].  Solution:
# Definition for an interval. # class Interval: # def __init__(self, s=0, e=0): # self.</description>
    </item>
    
    <item>
      <title>56. Merge Intervals</title>
      <link>http://www.hashnopolis.com/post/2018/08/56.-merge-intervals/</link>
      <pubDate>Fri, 24 Aug 2018 02:19:05 +0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/08/56.-merge-intervals/</guid>
      <description>Given a collection of intervals, merge all overlapping intervals.
Example 1:
Input: [[1,3],[2,6],[8,10],[15,18]] Output: [[1,6],[8,10],[15,18]] Explanation: Since intervals [1,3] and [2,6] overlaps, merge them into [1,6].  Example 2:
Input: [[1,4],[4,5]] Output: [[1,5]] Explanation: Intervals [1,4] and [4,5] are considered overlapping.  Solution:
# Definition for an interval. # class Interval: # def __init__(self, s=0, e=0): # self.start = s # self.end = e class Solution: def merge(self, intervals): &amp;quot;&amp;quot;&amp;quot; :type intervals: List[Interval] :rtype: List[Interval] &amp;quot;&amp;quot;&amp;quot; intervals.</description>
    </item>
    
    <item>
      <title>80. Remove Duplicates From Sorted Array II</title>
      <link>http://www.hashnopolis.com/post/2018/08/80.-remove-duplicates-from-sorted-array-ii/</link>
      <pubDate>Fri, 24 Aug 2018 00:48:48 +0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/08/80.-remove-duplicates-from-sorted-array-ii/</guid>
      <description>Given a sorted array nums, remove the duplicates in-place such that duplicates appeared at most twice and return the new length.
Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.
Example 1:
Given nums = [1,1,1,2,2,3], Your function should return length = 5, with the first five elements of nums being 1, 1, 2, 2 and 3 respectively.</description>
    </item>
    
    <item>
      <title>Remove Duplicates From Sorted Array</title>
      <link>http://www.hashnopolis.com/post/2018/08/remove-duplicates-from-sorted-array/</link>
      <pubDate>Thu, 23 Aug 2018 23:52:17 +0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/08/remove-duplicates-from-sorted-array/</guid>
      <description>Given a sorted array nums, remove the duplicates in-place such that each element appear only once and return the new length.
Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.
Example 1:
Given nums = [1,1,2], Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively. It doesn&#39;t matter what you leave beyond the returned length.</description>
    </item>
    
    <item>
      <title>4. Median of Two Sorted Arrays</title>
      <link>http://www.hashnopolis.com/post/2018/08/4.-median-of-two-sorted-arrays/</link>
      <pubDate>Tue, 21 Aug 2018 20:54:32 +0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/08/4.-median-of-two-sorted-arrays/</guid>
      <description>There are two sorted arrays nums1 and nums2 of size m and n respectively.
Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).
You may assume nums1 and nums2 cannot be both empty.
Example 1:
nums1 = [1, 3] nums2 = [2]  The median is 2.0
Example 2:
nums1 = [1, 2] nums2 = [3, 4]  The median is (2 + 3)/2 = 2.</description>
    </item>
    
    <item>
      <title>Remove Nth Node From End of List</title>
      <link>http://www.hashnopolis.com/post/2018/08/remove-nth-node-from-end-of-list/</link>
      <pubDate>Mon, 20 Aug 2018 23:33:38 +0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/08/remove-nth-node-from-end-of-list/</guid>
      <description>Given a linked list, remove the n-th node from the end of list and return its head.
Example:
Given linked list: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5, and n = 2. After removing the second node from the end, the linked list becomes 1-&amp;gt;2-&amp;gt;3-&amp;gt;5.  Note:
Given n will always be valid.
Follow up:
Could you do this in one pass?</description>
    </item>
    
    <item>
      <title>Search in Rotated Sorted Array II</title>
      <link>http://www.hashnopolis.com/post/2018/08/search-in-rotated-sorted-array-ii/</link>
      <pubDate>Wed, 15 Aug 2018 12:50:21 +0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/08/search-in-rotated-sorted-array-ii/</guid>
      <description>Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.
(i.e., [0,0,1,2,2,5,6] might become [2,5,6,0,0,1,2]).
You are given a target value to search. If found in the array return true, otherwise return false.
Example 1:
Input: nums = [2,5,6,0,0,1,2], target = 0 Output: true  Example 2:
Input: nums = [2,5,6,0,0,1,2], target = 3 Output: false  Follow up: - This is a follow up problem to Search in Rotated Sorted Array, where nums may contain duplicates.</description>
    </item>
    
  </channel>
</rss>