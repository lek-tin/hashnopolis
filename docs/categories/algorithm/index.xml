<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Algorithm on Hashnopolis</title>
    <link>http://www.hashnopolis.com/categories/algorithm/</link>
    <description>Recent content in Algorithm on Hashnopolis</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Hashnopolis</copyright>
    <lastBuildDate>Sat, 27 Oct 2018 10:34:19 -0700</lastBuildDate>
    
	<atom:link href="http://www.hashnopolis.com/categories/algorithm/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Find the Duplicate Number</title>
      <link>http://www.hashnopolis.com/post/2018/10/find-the-duplicate-number/</link>
      <pubDate>Sat, 27 Oct 2018 10:34:19 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/10/find-the-duplicate-number/</guid>
      <description>Given an array nums containing n + 1 integers where each integer is between 1 and n (inclusive), prove that at least one duplicate number must exist. Assume that there is only one duplicate number, find the duplicate one.
Example 1:
Input: [1,3,4,2,2] Output: 2  Example 2:
Input: [3,1,3,4,2] Output: 3  Note: You must not modify the array (assume the array is read only). You must use only constant, O(1) extra space.</description>
    </item>
    
    <item>
      <title>Invert Binary Tree</title>
      <link>http://www.hashnopolis.com/post/2018/10/invert-binary-tree/</link>
      <pubDate>Fri, 26 Oct 2018 23:12:09 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/10/invert-binary-tree/</guid>
      <description>Invert a binary tree.
 4 / \ 2 7 / \ / \ 1 3 6 9  to
 4 / \ 7 2 / \ / \ 9 6 3 1  Thoughts What if a node is NULL? A NULL has no children, so how to iterate deeper into the tree?
// Attempt // class Solution { // public: void swapNodes(*leftNode, *rightNode) { *temp = *leftNode; *leftNode = *rightNode; *rightNode = temp; return; } TreeNode* invertTree(TreeNode* root) { if (root == NULL) return invertTree(root-&amp;gt;left, ) } };  Solution:</description>
    </item>
    
    <item>
      <title>Integer to Roman</title>
      <link>http://www.hashnopolis.com/post/2018/10/integer-to-roman/</link>
      <pubDate>Fri, 26 Oct 2018 23:11:27 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/10/integer-to-roman/</guid>
      <description>Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.
Symbol Value I 1 V 5 X 10 L 50 C 100 D 500 M 1000  For example, two is written as II in Roman numeral, just two one&amp;rsquo;s added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II.</description>
    </item>
    
    <item>
      <title>Find First and Last Position of Element in Sorted Array</title>
      <link>http://www.hashnopolis.com/post/2018/10/find-first-and-last-position-of-element-in-sorted-array/</link>
      <pubDate>Fri, 26 Oct 2018 23:10:23 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/10/find-first-and-last-position-of-element-in-sorted-array/</guid>
      <description>Given an array of integers nums sorted in ascending order, find the starting and ending position of a given target value.
Your algorithm&amp;rsquo;s runtime complexity must be in the order of O(log n).
If the target is not found in the array, return [-1, -1].
Example 1:
Input: nums = [5,7,7,8,8,10], target = 8 Output: [3,4]  Example 2:
Input: nums = [5,7,7,8,8,10], target = 6 Output: [-1,-1]  Solution:</description>
    </item>
    
    <item>
      <title>Search in Rotated Sorted Array</title>
      <link>http://www.hashnopolis.com/post/2018/10/search-in-rotated-sorted-array/</link>
      <pubDate>Fri, 26 Oct 2018 23:08:49 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/10/search-in-rotated-sorted-array/</guid>
      <description>Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.
(i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]).
You are given a target value to search. If found in the array return its index, otherwise return -1.
You may assume no duplicate exists in the array.
Your algorithm&amp;rsquo;s runtime complexity must be in the order of O(log n).
Example 1:
Input: nums = [4,5,6,7,0,1,2], target = 0 Output: 4  Example 2:</description>
    </item>
    
    <item>
      <title>First Bad Version</title>
      <link>http://www.hashnopolis.com/post/2018/10/first-bad-version/</link>
      <pubDate>Fri, 26 Oct 2018 23:07:46 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/10/first-bad-version/</guid>
      <description>You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.
Suppose you have n versions [1, 2, ..., n] and you want to find out the first bad one, which causes all the following ones to be bad.</description>
    </item>
    
    <item>
      <title>Minimum Path Sum</title>
      <link>http://www.hashnopolis.com/post/2018/10/minimum-path-sum/</link>
      <pubDate>Fri, 26 Oct 2018 23:04:31 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/10/minimum-path-sum/</guid>
      <description>Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path.
Note: You can only move either down or right at any point in time.
Example:
Input: [ [1,3,1], [1,5,1], [4,2,1] ] Output: 7  Explanation: Because the path 1â†’3â†’1â†’1â†’1 minimizes the sum. Solution:
class Solution: def minPathSum(self, grid): &amp;quot;&amp;quot;&amp;quot; :type grid: List[List[int]] :rtype: int &amp;quot;&amp;quot;&amp;quot; for r in range(len(grid)): for c in range(len(grid[0])): if (r == 0 and c !</description>
    </item>
    
    <item>
      <title>House Robber</title>
      <link>http://www.hashnopolis.com/post/2018/10/house-robber/</link>
      <pubDate>Thu, 25 Oct 2018 23:45:32 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/10/house-robber/</guid>
      <description>You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night.
Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.</description>
    </item>
    
    <item>
      <title>Happy Number</title>
      <link>http://www.hashnopolis.com/post/2018/10/happy-number/</link>
      <pubDate>Thu, 25 Oct 2018 23:44:12 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/10/happy-number/</guid>
      <description>Write an algorithm to determine if a number is &amp;ldquo;happy&amp;rdquo;.
A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy numbers.</description>
    </item>
    
    <item>
      <title>Merge Two Sorted Lists</title>
      <link>http://www.hashnopolis.com/post/2018/10/merge-two-sorted-lists/</link>
      <pubDate>Thu, 25 Oct 2018 23:43:25 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/10/merge-two-sorted-lists/</guid>
      <description>Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.
Example:
Input: 1-&amp;gt;2-&amp;gt;4, 1-&amp;gt;3-&amp;gt;4 Output: 1-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;4  Solution:
class Solution: def mergeTwoLists(self, l1, l2): &amp;quot;&amp;quot;&amp;quot; :type l1: ListNode :type l2: ListNode :rtype: ListNode &amp;quot;&amp;quot;&amp;quot; if l1 == None: return l2 if l2 == None: return l1 root = ListNode(0) temp = root while l1 and l2: if l1.</description>
    </item>
    
    <item>
      <title>Merge Two Binary Trees</title>
      <link>http://www.hashnopolis.com/post/2018/10/merge-two-binary-trees/</link>
      <pubDate>Thu, 25 Oct 2018 23:42:27 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/10/merge-two-binary-trees/</guid>
      <description>Given two binary trees and imagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not.
You need to merge them into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node. Otherwise, the NOT null node will be used as the node of new tree.</description>
    </item>
    
    <item>
      <title>Multiply Strings</title>
      <link>http://www.hashnopolis.com/post/2018/10/multiply-strings/</link>
      <pubDate>Thu, 25 Oct 2018 23:40:08 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/10/multiply-strings/</guid>
      <description>Given two non-negative integers num1 and num2 represented as strings, return the product of num1 and num2, also represented as a string.
Example 1:
Input: num1 = &amp;quot;2&amp;quot;, num2 = &amp;quot;3&amp;quot; Output: &amp;quot;6&amp;quot;  Example 2:
Input: num1 = &amp;quot;123&amp;quot;, num2 = &amp;quot;456&amp;quot; Output: &amp;quot;56088&amp;quot;  Note: - The length of both num1 and num2 is &amp;lt; 110. - Both num1 and num2 contain only digits 0-9. - Both num1 and num2 do not contain any leading zero, except the number 0 itself.</description>
    </item>
    
    <item>
      <title>Kth Smallest Element in a BST</title>
      <link>http://www.hashnopolis.com/post/2018/10/kth-smallest-element-in-a-bst/</link>
      <pubDate>Wed, 24 Oct 2018 23:39:48 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/10/kth-smallest-element-in-a-bst/</guid>
      <description>Given a binary search tree, write a function kthSmallest to find the kth smallest element in it.
Note:
You may assume k is always valid, 1 â‰¤ k â‰¤ BST&#39;s total elements.  Example 1:
Input: root = [3,1,4,null,2], k = 1 Output: 1  Example 2: ```` Input: root = [5,3,6,2,4,null,null,1], k = 3 Output: 3
**Follow up:** What if the BST is modified (insert/delete operations) often and you need to find the kth smallest frequently?</description>
    </item>
    
    <item>
      <title>Kth Largest Element in an Array</title>
      <link>http://www.hashnopolis.com/post/2018/10/kth-largest-element-in-an-array/</link>
      <pubDate>Wed, 24 Oct 2018 23:38:20 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/10/kth-largest-element-in-an-array/</guid>
      <description>Find the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element.
Example 1:
Input: [3,2,1,5,6,4] and k = 2 Output: 5  Example 2:
Input: [3,2,3,1,2,4,5,5,6] and k = 4 Output: 4  Note: You may assume k is always valid, 1 â‰¤ k â‰¤ array&#39;s length. Solution:
class Solution: def findKthLargest(self, nums, k): if (nums == None or len(nums) == 0): return 0 left, right = 0, len(nums) - 1 def swap(nums, i, j): temp = nums[i] nums[i] = nums[j] nums[j] = temp def partition(nums, left, right): pivot = nums[left] l = left + 1 r = right while l &amp;lt;= r: if nums[l] &amp;lt; pivot and nums[r] &amp;gt; pivot: swap(nums, l, r) l += 1 r -= 1 if nums[l] &amp;gt;= pivot: l += 1 if nums[r] &amp;lt;= pivot: r -= 1 swap(nums, left, r) return r while True: pos = partition(nums, left, right) if pos + 1 == k: return nums[pos] elif pos + 1 &amp;gt; k: right = pos - 1 elif pos + 1 &amp;lt; k: left = pos + 1  </description>
    </item>
    
    <item>
      <title>Group Anagrams</title>
      <link>http://www.hashnopolis.com/post/2018/10/group-anagrams/</link>
      <pubDate>Mon, 22 Oct 2018 12:01:59 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/10/group-anagrams/</guid>
      <description>Given an array of strings, group anagrams together.
Example:
Input: [&amp;quot;eat&amp;quot;, &amp;quot;tea&amp;quot;, &amp;quot;tan&amp;quot;, &amp;quot;ate&amp;quot;, &amp;quot;nat&amp;quot;, &amp;quot;bat&amp;quot;], Output: [ [&amp;quot;ate&amp;quot;,&amp;quot;eat&amp;quot;,&amp;quot;tea&amp;quot;], [&amp;quot;nat&amp;quot;,&amp;quot;tan&amp;quot;], [&amp;quot;bat&amp;quot;] ]  Note: - All inputs will be in lowercase. - The order of your output does not matter. Solution:
class Solution(object): def groupAnagrams(self, strs): &amp;quot;&amp;quot;&amp;quot; :type strs: List[str] :rtype: List[List[str]] &amp;quot;&amp;quot;&amp;quot; primeNums = { &amp;quot;a&amp;quot;: 2, &amp;quot;b&amp;quot;: 3, &amp;quot;c&amp;quot;: 5, &amp;quot;d&amp;quot;: 7, &amp;quot;e&amp;quot;: 11, &amp;quot;f&amp;quot;: 13, &amp;quot;g&amp;quot;: 17, &amp;quot;h&amp;quot;: 19, &amp;quot;i&amp;quot;: 23, &amp;quot;j&amp;quot;: 29, &amp;quot;k&amp;quot;: 31, &amp;quot;m&amp;quot;: 37, &amp;quot;l&amp;quot;: 41, &amp;quot;n&amp;quot;: 43, &amp;quot;o&amp;quot;: 47, &amp;quot;p&amp;quot;: 53, &amp;quot;q&amp;quot;: 59, &amp;quot;r&amp;quot;: 61, &amp;quot;s&amp;quot;: 67, &amp;quot;t&amp;quot;: 71, &amp;quot;u&amp;quot;: 73, &amp;quot;v&amp;quot;: 79, &amp;quot;w&amp;quot;: 83, &amp;quot;x&amp;quot;: 89, &amp;quot;y&amp;quot;: 97, &amp;quot;z&amp;quot;: 101 } def encode(string): res = 1 for s in list(string): res *= primeNums[s] return res anagrams = {} for string in strs: code = encode(string) if anagrams.</description>
    </item>
    
    <item>
      <title>Linked List Cycle II</title>
      <link>http://www.hashnopolis.com/post/2018/10/linked-list-cycle-ii/</link>
      <pubDate>Sun, 21 Oct 2018 23:08:30 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/10/linked-list-cycle-ii/</guid>
      <description>Given a linked list, return the node where the cycle begins. If there is no cycle, return null.
Note: Do not modify the linked list.
Follow up: Can you solve it without using extra space? Solution:
# Definition for singly-linked list. # class ListNode(object): # def __init__(self, x): # self.val = x # self.next = None class Solution(object): def detectCycle(self, head): &amp;quot;&amp;quot;&amp;quot; :type head: ListNode :rtype: ListNode &amp;quot;&amp;quot;&amp;quot; if head == None: return None slow = head fast = head hasCycle = False while fast.</description>
    </item>
    
    <item>
      <title>Linked List Cycle</title>
      <link>http://www.hashnopolis.com/post/2018/10/linked-list-cycle/</link>
      <pubDate>Sun, 21 Oct 2018 23:07:55 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/10/linked-list-cycle/</guid>
      <description>Given a linked list, determine if it has a cycle in it.
Follow up: Can you solve it without using extra space?
Solution:
# Definition for singly-linked list. # class ListNode(object): # def __init__(self, x): # self.val = x # self.next = None class Solution(object): def hasCycle(self, head): &amp;quot;&amp;quot;&amp;quot; :type head: ListNode :rtype: bool &amp;quot;&amp;quot;&amp;quot; slow = head fast = head while fast: if fast and not fast.next: return False fast = fast.</description>
    </item>
    
    <item>
      <title>Reverse Linked List</title>
      <link>http://www.hashnopolis.com/post/2018/10/reverse-linked-list/</link>
      <pubDate>Tue, 02 Oct 2018 23:51:13 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/10/reverse-linked-list/</guid>
      <description>Reverse a singly linked list.
Example:
Input: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5-&amp;gt;NULL Output: 5-&amp;gt;4-&amp;gt;3-&amp;gt;2-&amp;gt;1-&amp;gt;NULL  Follow up:
A linked list can be reversed either iteratively or recursively. Could you implement both? Solution:
# Definition for singly-linked list. # class ListNode: # def __init__(self, x): # self.val = x # self.next = None class Solution: def reverseList(self, head): &amp;quot;&amp;quot;&amp;quot; :type head: ListNode :rtype: ListNode &amp;quot;&amp;quot;&amp;quot; curr, prev, after = head, None, ListNode(None) while curr != None: after = curr.</description>
    </item>
    
    <item>
      <title>Reverse Linked List II</title>
      <link>http://www.hashnopolis.com/post/2018/09/reverse-linked-list-ii/</link>
      <pubDate>Sun, 30 Sep 2018 22:19:41 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/09/reverse-linked-list-ii/</guid>
      <description>Reverse a linked list from position m to n. Do it in one-pass.
Note: 1 â‰¤ m â‰¤ n â‰¤ length of list.
Example:
Input: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5-&amp;gt;NULL, m = 2, n = 4 Output: 1-&amp;gt;4-&amp;gt;3-&amp;gt;2-&amp;gt;5-&amp;gt;NULL  *Solution:**
class Solution: def reverseBetween(self, head, m, n): &amp;quot;&amp;quot;&amp;quot; :type head: ListNode :type m: int :type n: int :rtype: ListNode &amp;quot;&amp;quot;&amp;quot; dummy = ListNode(None) dummy.next = head pre = dummy curr = dummy.next for i in range(1, m): curr = curr.</description>
    </item>
    
    <item>
      <title>Gray Code</title>
      <link>http://www.hashnopolis.com/post/2018/09/gray-code/</link>
      <pubDate>Tue, 25 Sep 2018 08:14:01 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/09/gray-code/</guid>
      <description>The gray code is a binary numeral system where two successive values differ in only one bit.
Given a non-negative integer n representing the total number of bits in the code, print the sequence of gray code. A gray code sequence must begin with 0.
For example, given n = 2, return [0,1,3,2]. Its gray code sequence is:
00 - 0 01 - 1 11 - 3 10 - 2  Note: For a given n, a gray code sequence is not uniquely defined.</description>
    </item>
    
    <item>
      <title>Add Digits</title>
      <link>http://www.hashnopolis.com/post/2018/09/add-digits/</link>
      <pubDate>Sun, 23 Sep 2018 23:18:25 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/09/add-digits/</guid>
      <description>Given a non-negative integer num, repeatedly add all its digits until the result has only one digit.
For example:
Given num = 38, the process is like: 3 + 8 = 11, 1 + 1 = 2. Since 2 has only one digit, return it.
Follow up: Could you do it without any loop/recursion in O(1) runtime?
Credits: Special thanks to @jianchao.li.fighter for adding this problem and creating all test cases.</description>
    </item>
    
    <item>
      <title>Remove Duplicates From Sorted List II</title>
      <link>http://www.hashnopolis.com/post/2018/09/remove-duplicates-from-sorted-list-ii/</link>
      <pubDate>Wed, 19 Sep 2018 10:38:38 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/09/remove-duplicates-from-sorted-list-ii/</guid>
      <description>Given a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list.
Example 1:
Input: 1-&amp;gt;2-&amp;gt;3-&amp;gt;3-&amp;gt;4-&amp;gt;4-&amp;gt;5 Output: 1-&amp;gt;2-&amp;gt;5  Example 2:
Input: 1-&amp;gt;1-&amp;gt;1-&amp;gt;2-&amp;gt;3 Output: 2-&amp;gt;3  </description>
    </item>
    
    <item>
      <title>Remove Linked List Elements</title>
      <link>http://www.hashnopolis.com/post/2018/09/remove-linked-list-elements/</link>
      <pubDate>Tue, 18 Sep 2018 16:07:09 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/09/remove-linked-list-elements/</guid>
      <description>Remove all elements from a linked list of integers that have value val.
Example:
Input: 1-&amp;gt;2-&amp;gt;6-&amp;gt;3-&amp;gt;4-&amp;gt;5-&amp;gt;6, val = 6 Output: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5  Solution:
# Definition for singly-linked list. # class ListNode: # def __init__(self, x): # self.val = x # self.next = None class Solution: def removeElements(self, head, val): &amp;quot;&amp;quot;&amp;quot; :type head: ListNode :type val: int :rtype: ListNode &amp;quot;&amp;quot;&amp;quot; pre = ListNode(0) pre.next = head pos = pre while pos.next !</description>
    </item>
    
    <item>
      <title>Unique Binary Search Trees</title>
      <link>http://www.hashnopolis.com/post/2018/09/unique-binary-search-trees/</link>
      <pubDate>Sun, 16 Sep 2018 15:06:01 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/09/unique-binary-search-trees/</guid>
      <description>Given n, how many structurally unique BST&amp;rsquo;s (binary search trees) that store values 1 &amp;hellip; n?
Example:
Input: 3 Output: 5 Explanation: Given n = 3, there are a total of 5 unique BST&#39;s: 1 3 3 2 1 \ / / / \ \ 3 2 1 1 3 2 / / \ \ 2 1 2 3  Exaplanation:
n = 3 root: 1 left: 0 right: 2 f(0)*f(2); root: 2 left: 1 right: 1 f(1)*f(1); root: 3 left: 2 right: 0 f(2)*f(0);  Solution:</description>
    </item>
    
    <item>
      <title>Symmetric Tree</title>
      <link>http://www.hashnopolis.com/post/2018/09/symmetric-tree/</link>
      <pubDate>Sun, 16 Sep 2018 15:05:12 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/09/symmetric-tree/</guid>
      <description>Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).
For example, this binary tree [1,2,2,3,4,4,3] is symmetric:
 1 / \ 2 2 / \ / \ 3 4 4 3  But the following [1,2,2,null,3,null,3] is not:
 1 / \ 2 2 \ \ 3 3  Note: Bonus points if you could solve it both recursively and iteratively.
Solution:</description>
    </item>
    
    <item>
      <title>Top K Frequent Elements</title>
      <link>http://www.hashnopolis.com/post/2018/09/top-k-frequent-elements/</link>
      <pubDate>Sun, 16 Sep 2018 15:04:30 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/09/top-k-frequent-elements/</guid>
      <description>Given a non-empty array of integers, return the k most frequent elements.
For example, Given [1,1,1,2,2,3] and k = 2, return [1,2]. Note: You may assume k is always valid, 1 â‰¤ k â‰¤ number of unique elements. Your algorithm&amp;rsquo;s time complexity must be better than O(n log n), where n is the array&amp;rsquo;s size. Solution:
class Solution: def topKFrequent(self, nums, k): &amp;quot;&amp;quot;&amp;quot; :type nums: List[int] :type k: int :rtype: List[int] &amp;quot;&amp;quot;&amp;quot; freqMap = dict() for num in nums: if freqMap.</description>
    </item>
    
    <item>
      <title>Same Tree</title>
      <link>http://www.hashnopolis.com/post/2018/09/same-tree/</link>
      <pubDate>Sun, 16 Sep 2018 15:03:53 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/09/same-tree/</guid>
      <description>Given two binary trees, write a function to check if they are the same or not.
Two binary trees are considered the same if they are structurally identical and the nodes have the same value.
Example 1:
Input: 1 1 / \ / \ 2 3 2 3 [1,2,3], [1,2,3] Output: true  Example 2:
Input: 1 1 / \ 2 2 [1,2], [1,null,2] Output: false  Example 3:
Input: 1 1 / \ / \ 2 1 1 2 [1,2,1], [1,1,2] Output: false  Solution</description>
    </item>
    
    <item>
      <title>Remove Element</title>
      <link>http://www.hashnopolis.com/post/2018/09/remove-element/</link>
      <pubDate>Sun, 16 Sep 2018 15:02:20 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/09/remove-element/</guid>
      <description>Given an array nums and a value val, remove all instances of that value in-place and return the new length.
Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.
The order of elements can be changed. It doesn&amp;rsquo;t matter what you leave beyond the new length.
Example 1:
Given nums = [3,2,2,3], val = 3, Your function should return length = 2, with the first two elements of nums being 2.</description>
    </item>
    
    <item>
      <title>Remove Duplicates From Sorted List</title>
      <link>http://www.hashnopolis.com/post/2018/09/remove-duplicates-from-sorted-list/</link>
      <pubDate>Sun, 16 Sep 2018 15:01:24 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/09/remove-duplicates-from-sorted-list/</guid>
      <description>Given a sorted linked list, delete all duplicates such that each element appear only once.
Example 1:
Input: 1-&amp;gt;1-&amp;gt;2 Output: 1-&amp;gt;2  Example 2:
Input: 1-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;3 Output: 1-&amp;gt;2-&amp;gt;3  Solution:
# Definition for singly-linked list. # class ListNode(object): # def __init__(self, x): # self.val = x # self.next = None class Solution(object): def deleteDuplicates(self, head): &amp;quot;&amp;quot;&amp;quot; :type head: ListNode :rtype: ListNode &amp;quot;&amp;quot;&amp;quot; curr = head while curr != None and curr.</description>
    </item>
    
    <item>
      <title>Power of Two</title>
      <link>http://www.hashnopolis.com/post/2018/09/power-of-two/</link>
      <pubDate>Sat, 15 Sep 2018 12:56:41 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/09/power-of-two/</guid>
      <description>Given an integer, write a function to determine if it is a power of two.
Example 1:
Input: 1 Output: true Explanation: 2**0 = 1  Example 2:
Input: 16 Output: true Explanation: 2**4 = 16  Example 3:
Input: 218 Output: false  Solution:
class Solution: def isPowerOfTwo(self, n): &amp;quot;&amp;quot;&amp;quot; :type n: int :rtype: bool &amp;quot;&amp;quot;&amp;quot; if n == 0: return False if n &amp;amp; (n - 1) == 0: return True return False  </description>
    </item>
    
    <item>
      <title>Plus One</title>
      <link>http://www.hashnopolis.com/post/2018/09/plus-one/</link>
      <pubDate>Sat, 15 Sep 2018 12:56:08 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/09/plus-one/</guid>
      <description>Given a non-empty array of digits representing a non-negative integer, plus one to the integer.
The digits are stored such that the most significant digit is at the head of the list, and each element in the array contain a single digit.
You may assume the integer does not contain any leading zero, except the number 0 itself.
Example 1:
Input: [1,2,3] Output: [1,2,4] Explanation: The array represents the integer 123.</description>
    </item>
    
    <item>
      <title>Swap Nodes in Pairs</title>
      <link>http://www.hashnopolis.com/post/2018/09/swap-nodes-in-pairs/</link>
      <pubDate>Sat, 15 Sep 2018 12:55:20 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/09/swap-nodes-in-pairs/</guid>
      <description>Given a linked list, swap every two adjacent nodes and return its head.
Example:
Given 1-&amp;gt;2-&amp;gt;3-&amp;gt;4, you should return the list as 2-&amp;gt;1-&amp;gt;4-&amp;gt;3.  Note: - Your algorithm should use only constant extra space. - You may not modify the values in the list&amp;rsquo;s nodes, only nodes itself may be changed. Solution:
# Definition for singly-linked list. # class ListNode(object): # def __init__(self, x): # self.val = x # self.next = None class Solution(object): def swapPairs(self, head): &amp;quot;&amp;quot;&amp;quot; :type head: ListNode :rtype: ListNode &amp;quot;&amp;quot;&amp;quot; # https://www.</description>
    </item>
    
    <item>
      <title>Unique Paths</title>
      <link>http://www.hashnopolis.com/post/2018/09/unique-paths/</link>
      <pubDate>Sat, 15 Sep 2018 12:54:17 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/09/unique-paths/</guid>
      <description>A robot is located at the top-left corner of a m x n grid (marked &amp;lsquo;Start&amp;rsquo; in the diagram below).
The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked &amp;lsquo;Finish&amp;rsquo; in the diagram below).
How many possible unique paths are there?
Above is a 7 x 3 grid. How many possible unique paths are there?</description>
    </item>
    
    <item>
      <title>Valid Anagram</title>
      <link>http://www.hashnopolis.com/post/2018/09/valid-anagram/</link>
      <pubDate>Sat, 15 Sep 2018 12:53:21 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/09/valid-anagram/</guid>
      <description>Given two strings s and t , write a function to determine if t is an anagram of s.
Example 1:
Input: s = &amp;quot;anagram&amp;quot;, t = &amp;quot;nagaram&amp;quot; Output: true  Example 2:
Input: s = &amp;quot;rat&amp;quot;, t = &amp;quot;car&amp;quot; Output: false  Note: You may assume the string contains only lowercase alphabets.
Follow up: What if the inputs contain unicode characters? How would you adapt your solution to such case?</description>
    </item>
    
    <item>
      <title>Ugly Number</title>
      <link>http://www.hashnopolis.com/post/2018/09/ugly-number/</link>
      <pubDate>Sat, 15 Sep 2018 12:52:53 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/09/ugly-number/</guid>
      <description>Write a program to check whether a given number is an ugly number.
Ugly numbers are positive numbers whose prime factors only include 2, 3, 5.
Example 1:
Input: 6 Output: true Explanation: 6 = 2 Ã— 3  Example 2:
Input: 8 Output: true Explanation: 8 = 2 Ã— 2 Ã— 2  Example 3:
Input: 14 Output: false Explanation: 14 is not ugly since it includes another prime factor 7.</description>
    </item>
    
    <item>
      <title>Subsets</title>
      <link>http://www.hashnopolis.com/post/2018/09/subsets/</link>
      <pubDate>Sat, 15 Sep 2018 12:48:42 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/09/subsets/</guid>
      <description>Given a set of distinct integers, nums, return all possible subsets (the power set).
Note: The solution set must not contain duplicate subsets.
Example:
Input: nums = [1,2,3] Output: [ [3], [1], [2], [1,2,3], [1,3], [2,3], [1,2], [] ]  Solution:
class Solution: def subsets(self, nums): &amp;quot;&amp;quot;&amp;quot; :type nums: List[int] :rtype: List[List[int]] &amp;quot;&amp;quot;&amp;quot; res = [] def dfs(nums, index, path): res.append(path) for i in range(index, len(nums)): dfs(nums, i+1, path+[nums[i]]) dfs(sorted(nums), 0, []) return res  </description>
    </item>
    
    <item>
      <title>Roman to Integer</title>
      <link>http://www.hashnopolis.com/post/2018/09/roman-to-integer/</link>
      <pubDate>Sat, 15 Sep 2018 12:47:14 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/09/roman-to-integer/</guid>
      <description>Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.
Symbol Value I 1 V 5 X 10 L 50 C 100 D 500 M 1000  For example, two is written as II in Roman numeral, just two one&amp;rsquo;s added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II.</description>
    </item>
    
    <item>
      <title>Single Number III</title>
      <link>http://www.hashnopolis.com/post/2018/09/single-number-iii/</link>
      <pubDate>Fri, 14 Sep 2018 11:54:43 +0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/09/single-number-iii/</guid>
      <description>Given an array of numbers nums, in which exactly two elements appear only once and all the other elements appear exactly twice. Find the two elements that appear only once.
For example: Given nums = [1, 2, 1, 3, 2, 5], return [3, 5]. Note:
 The order of the result is not important. So in the above example, [5, 3] is also correct. Your algorithm should run in linear runtime complexity.</description>
    </item>
    
    <item>
      <title>Single Number II</title>
      <link>http://www.hashnopolis.com/post/2018/09/single-number-ii/</link>
      <pubDate>Fri, 14 Sep 2018 11:53:51 +0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/09/single-number-ii/</guid>
      <description>Given a non-empty array of integers, every element appears three times except for one, which appears exactly once. Find that single one.
Note:
Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?
Example 1:
Input: [2,2,3,2] Output: 3  Example 2:
Input: [0,1,0,1,0,1,99] Output: 99  Solution:
class Solution: def singleNumber(self, nums): &amp;quot;&amp;quot;&amp;quot; :type nums: List[int] :rtype: int &amp;quot;&amp;quot;&amp;quot; # https://www.cnblogs.com/ganganloveu/p/4110996.html # https://blog.csdn.net/karen0310/article/details/78226261 ones, twos = 0, 0 for _, num in enumerate(nums): ones = (ones ^ num) &amp;amp; ~twos twos = (twos ^ num) &amp;amp; ~ones print(bin(num), &amp;quot;ones: &amp;quot;, bin(ones), &amp;quot;twos: &amp;quot;, bin(twos)) return ones  </description>
    </item>
    
    <item>
      <title>Single Number</title>
      <link>http://www.hashnopolis.com/post/2018/09/single-number/</link>
      <pubDate>Fri, 14 Sep 2018 11:53:00 +0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/09/single-number/</guid>
      <description> Given a non-empty array of integers, every element appears twice except for one. Find that single one. Note: Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?
Example 1:
Input: [2,2,1] Output: 1 Example 2:  Input: [4,1,2,1,2] Output: 4  Solution:
// Java class Solution { public int singleNumber(int[] nums) { int result=0; for(int num : nums) { result=result^num; } return result; } }  </description>
    </item>
    
    <item>
      <title>Find Peak Element</title>
      <link>http://www.hashnopolis.com/post/2018/09/find-peak-element/</link>
      <pubDate>Fri, 14 Sep 2018 11:51:46 +0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/09/find-peak-element/</guid>
      <description>A peak element is an element that is greater than its neighbors.
Given an input array nums, where nums[i] â‰  nums[i+1], find a peak element and return its index.
The array may contain multiple peaks, in that case return the index to any one of the peaks is fine.
You may imagine that nums[-1] = nums[n] = -âˆž.
Example 1:
Input: nums = [1,2,3,1] Output: 2 Explanation: 3 is a peak element and your function should return the index number 2.</description>
    </item>
    
    <item>
      <title>Find Minimum in Rotated Sorted Array</title>
      <link>http://www.hashnopolis.com/post/2018/09/find-minimum-in-rotated-sorted-array/</link>
      <pubDate>Fri, 14 Sep 2018 11:50:46 +0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/09/find-minimum-in-rotated-sorted-array/</guid>
      <description>Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.
(i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]).
Find the minimum element.
You may assume no duplicate exists in the array.
Example 1:
Input: [3,4,5,1,2] Output: 1  Example 2:
Input: [4,5,6,7,0,1,2] Output: 0  Solution:
class Solution: def findMin(self, nums): &amp;quot;&amp;quot;&amp;quot; :type nums: List[int] :rtype: int &amp;quot;&amp;quot;&amp;quot; if len(nums) == 1: return nums[0] if len(nums) == 2: return min(nums[0], nums[1]) if nums[0] &amp;lt; nums[len(nums)-1]: return nums[0] if nums[len(nums)-2] &amp;gt; nums[len(nums)-1]: return nums[len(nums)-1] for i in range(1, len(nums)-1): if nums[i] &amp;lt; nums[i-1] and nums[i] &amp;lt; nums[i+1]: return nums[i] def bsFindMin(self, nums): l, r = 0, len(nums) - 1 while l &amp;lt; r: m = (l + r) // 2 if nums[m] &amp;gt; nums[m - 1] and nums[m] &amp;gt; nums[m + 1]: return nums[m + 1] if nums[m] &amp;lt; nums[m - 1] and nums[m] &amp;lt; nums[m + 1]: return nums[m] if nums[m] &amp;gt;= nums[r]: l = m else: r = m return nums[0]  </description>
    </item>
    
    <item>
      <title>Delete Node in a Linked List</title>
      <link>http://www.hashnopolis.com/post/2018/09/delete-node-in-a-linked-list/</link>
      <pubDate>Fri, 14 Sep 2018 11:49:07 +0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/09/delete-node-in-a-linked-list/</guid>
      <description>Write a function to delete a node (except the tail) in a singly linked list, given only access to that node.
Supposed the linked list is 1 -&amp;gt; 2 -&amp;gt; 3 -&amp;gt; 4 and you are given the third node with value 3, the linked list should become 1 -&amp;gt; 2 -&amp;gt; 4 after calling your function.
Solution:
# Definition for singly-linked list. # class ListNode(object): # def __init__(self, x): # self.</description>
    </item>
    
    <item>
      <title>Convert Sorted Array to Binary Search Tree</title>
      <link>http://www.hashnopolis.com/post/2018/09/convert-sorted-array-to-binary-search-tree/</link>
      <pubDate>Fri, 14 Sep 2018 10:23:36 +0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/09/convert-sorted-array-to-binary-search-tree/</guid>
      <description>Given an array where elements are sorted in ascending order, convert it to a height balanced BST.
For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.
Example:
Given the sorted array: [-10,-3,0,5,9], One possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST: 0 / \ -3 9 / / -10 5  Solution:</description>
    </item>
    
    <item>
      <title>Binary Tree Right Side View</title>
      <link>http://www.hashnopolis.com/post/2018/09/binary-tree-right-side-view/</link>
      <pubDate>Thu, 13 Sep 2018 23:03:06 +0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/09/binary-tree-right-side-view/</guid>
      <description>Given a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom.
Example:
Input: [1,2,3,null,5,null,4] Output: [1, 3, 4] Explanation: 1 &amp;lt;--- / \ 2 3 &amp;lt;--- \ \ 5 4 &amp;lt;---  Solution:
# Definition for a binary tree node. # class TreeNode: # def __init__(self, x): # self.val = x # self.left = None # self.</description>
    </item>
    
    <item>
      <title>Binary Tree Preorder Traversal</title>
      <link>http://www.hashnopolis.com/post/2018/09/binary-tree-preorder-traversal/</link>
      <pubDate>Thu, 13 Sep 2018 23:02:11 +0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/09/binary-tree-preorder-traversal/</guid>
      <description>Given a binary tree, return the preorder traversal of its nodes&amp;rsquo; values.
Example:
Input: [1,null,2,3] 1 \ 2 / 3 Output: [1,2,3]  Follow up: Recursive solution is trivial, could you do it iteratively?
Solution:
# Definition for a binary tree node. # class TreeNode(object): # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution(object): def preorderTraversal_1(self, root): &amp;quot;&amp;quot;&amp;quot; :type root: TreeNode :rtype: List[int] &amp;quot;&amp;quot;&amp;quot; if root is None: return [] return [root.</description>
    </item>
    
    <item>
      <title>Binary Tree Postorder Traversal</title>
      <link>http://www.hashnopolis.com/post/2018/09/binary-tree-postorder-traversal/</link>
      <pubDate>Thu, 13 Sep 2018 23:01:30 +0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/09/binary-tree-postorder-traversal/</guid>
      <description>Given a binary tree, return the postorder traversal of its nodes&amp;rsquo; values.
Example:
Input: [1,null,2,3] 1 \ 2 / 3 Output: [3,2,1]  Follow up:
Recursive solution is trivial, could you do it iteratively?
Solution:
RecursiveðŸ‘‡
# Definition for a binary tree node. # class TreeNode: # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution: def postorderTraversal(self, root): &amp;quot;&amp;quot;&amp;quot; :type root: TreeNode :rtype: List[int] &amp;quot;&amp;quot;&amp;quot; def traverse(node): if node == None: return [] return traverse(node.</description>
    </item>
    
    <item>
      <title>Binary Tree Paths</title>
      <link>http://www.hashnopolis.com/post/2018/09/binary-tree-paths/</link>
      <pubDate>Thu, 13 Sep 2018 23:00:42 +0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/09/binary-tree-paths/</guid>
      <description>Given a binary tree, return all root-to-leaf paths.
Note: A leaf is a node with no children.
Example:
Input: 1 / \ 2 3 \ 5 Output: [&amp;quot;1-&amp;gt;2-&amp;gt;5&amp;quot;, &amp;quot;1-&amp;gt;3&amp;quot;]  Explanation: All root-to-leaf paths are: 1-&amp;gt;2-&amp;gt;5, 1-&amp;gt;3
Solution:
# Definition for a binary tree node. # class TreeNode: # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution: def binaryTreePaths(self, root): &amp;quot;&amp;quot;&amp;quot; :type root: TreeNode :rtype: List[str] &amp;quot;&amp;quot;&amp;quot; res = [] def traverse(root, path): if root == None: return path += str(root.</description>
    </item>
    
    <item>
      <title>Binary Tree Level Order Traversal</title>
      <link>http://www.hashnopolis.com/post/2018/09/binary-tree-level-order-traversal/</link>
      <pubDate>Thu, 13 Sep 2018 22:59:49 +0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/09/binary-tree-level-order-traversal/</guid>
      <description>Given a binary tree, return the level order traversal of its nodes&amp;rsquo; values. (ie, from left to right, level by level).
For example:
Given binary tree `[3,9,20,null,null,15,7]`, 3 / \ 9 20 / \ 15 7  return its level order traversal as:
[ [3], [9,20], [15,7] ]  Solution:
# Definition for a binary tree node. # class TreeNode: # def __init__(self, x): # self.val = x # self.left = None # self.</description>
    </item>
    
    <item>
      <title>Binary Tree Level Order Traversal II</title>
      <link>http://www.hashnopolis.com/post/2018/09/binary-tree-level-order-traversal-ii/</link>
      <pubDate>Thu, 13 Sep 2018 22:59:17 +0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/09/binary-tree-level-order-traversal-ii/</guid>
      <description>Given a binary tree, return the bottom-up level order traversal of its nodes&amp;rsquo; values. (ie, from left to right, level by level from leaf to root).
For example: Given binary tree [3,9,20,null,null,15,7],
 3 / \ 9 20 / \ 15 7  return its bottom-up level order traversal as:
[ [15,7], [9,20], [3] ]  Solution:
# Definition for a binary tree node. # class TreeNode: # def __init__(self, x): # self.</description>
    </item>
    
    <item>
      <title>Binary Tree Inorder Traversal</title>
      <link>http://www.hashnopolis.com/post/2018/09/binary-tree-inorder-traversal/</link>
      <pubDate>Thu, 13 Sep 2018 22:57:42 +0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/09/binary-tree-inorder-traversal/</guid>
      <description>Given a binary tree, return the inorder traversal of its nodes&amp;rsquo; values.
Example:
Input: [1,null,2,3] 1 \ 2 / 3 Output: [1,3,2]  Follow up: the Recursive solution is trivial, could you do it iteratively?
Solution
# Definition for a binary tree node. # class TreeNode: # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution: def inorderTraversal(self, root): &amp;quot;&amp;quot;&amp;quot; :type root: TreeNode :rtype: List[int] &amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot;Check root == None to reduce time on checking&amp;quot;&amp;quot;&amp;quot; if root == None: return [] stack = [] result = [] current = root while (current!</description>
    </item>
    
    <item>
      <title>Combination Sum III</title>
      <link>http://www.hashnopolis.com/post/2018/09/combination-sum-iii/</link>
      <pubDate>Mon, 10 Sep 2018 21:42:37 +0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/09/combination-sum-iii/</guid>
      <description>Find all possible combinations of k numbers that add up to a number n, given that only numbers from 1 to 9 can be used and each combination should be a unique set of numbers.
Note:
All numbers will be positive integers. The solution set must not contain duplicate combinations. Example 1:
Input: k = 3, n = 7 Output: [[1,2,4]]  Example 2:
Input: k = 3, n = 9 Output: [[1,2,6], [1,3,5], [2,3,4]]  Solution:</description>
    </item>
    
    <item>
      <title>Combination Sum</title>
      <link>http://www.hashnopolis.com/post/2018/09/combination-sum/</link>
      <pubDate>Mon, 10 Sep 2018 21:42:01 +0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/09/combination-sum/</guid>
      <description>Given a set of candidate numbers (candidates) (without duplicates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target.
The same repeated number may be chosen from candidates unlimited number of times.
Note:
All numbers (including target) will be positive integers. The solution set must not contain duplicate combinations. Example 1:
Input: candidates = [2,3,6,7], target = 7, A solution set is: [ [7], [2,2,3] ]  Example 2:</description>
    </item>
    
    <item>
      <title>Combinations</title>
      <link>http://www.hashnopolis.com/post/2018/09/combinations/</link>
      <pubDate>Mon, 10 Sep 2018 21:41:18 +0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/09/combinations/</guid>
      <description>Given two integers n and k, return all possible combinations of k numbers out of 1 ... n.
Example:
Input: n = 4, k = 2 Output: [ [2,4], [3,4], [2,3], [1,2], [1,3], [1,4], ]  Solution:
class Solution: def combine(self, n, k): &amp;quot;&amp;quot;&amp;quot; :type n: int :type k: int :rtype: List[List[int]] &amp;quot;&amp;quot;&amp;quot; res = [] nums = list(range(1, n+1)) def iterate(index, tempAns): ans = list(tempAns) if len(ans) &amp;gt; k: return if index &amp;lt; n: ans.</description>
    </item>
    
    <item>
      <title>Combine Two Tables</title>
      <link>http://www.hashnopolis.com/post/2018/09/combine-two-tables/</link>
      <pubDate>Mon, 10 Sep 2018 21:40:30 +0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/09/combine-two-tables/</guid>
      <description>Table: Person
+-------------+---------+ | Column Name | Type | +-------------+---------+ | PersonId | int | | FirstName | varchar | | LastName | varchar | +-------------+---------+ PersonId is the primary key column for this table.  Table: Address
+-------------+---------+ | Column Name | Type | +-------------+---------+ | AddressId | int | | PersonId | int | | City | varchar | | State | varchar | +-------------+---------+ AddressId is the primary key column for this table.</description>
    </item>
    
    <item>
      <title>Contains Duplicate</title>
      <link>http://www.hashnopolis.com/post/2018/09/contains-duplicate/</link>
      <pubDate>Mon, 10 Sep 2018 21:39:18 +0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/09/contains-duplicate/</guid>
      <description>Given an array of integers, find if the array contains any duplicates.
Your function should return true if any value appears at least twice in the array, and it should return false if every element is distinct.
Example 1:
Input: [1,2,3,1] Output: true  Example 2:
Input: [1,2,3,4] Output: false  Example 3:
Input: [1,1,1,3,3,4,3,2,4,2] Output: true  Solution:
class Solution: def containsDuplicate(self, nums): &amp;quot;&amp;quot;&amp;quot; :type nums: List[int] :rtype: bool &amp;quot;&amp;quot;&amp;quot; uniqueNums = set(nums) if (len(uniqueNums) !</description>
    </item>
    
    <item>
      <title>Climbing Stairs</title>
      <link>http://www.hashnopolis.com/post/2018/09/climbing-stairs/</link>
      <pubDate>Sun, 09 Sep 2018 15:16:10 +0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/09/climbing-stairs/</guid>
      <description>You are climbing a stair case. It takes n steps to reach to the top.
Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?
Note: Given n will be a positive integer.
Example 1:
Input: 2 Output: 2 Explanation: There are two ways to climb to the top. 1. 1 step + 1 step 2. 2 steps  Example 2:</description>
    </item>
    
    <item>
      <title>Binary Search Tree Iterator</title>
      <link>http://www.hashnopolis.com/post/2018/09/binary-search-tree-iterator/</link>
      <pubDate>Sun, 09 Sep 2018 15:15:09 +0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/09/binary-search-tree-iterator/</guid>
      <description>Implement an iterator over a binary search tree (BST). Your iterator will be initialized with the root node of a BST.
Calling next() will return the next smallest number in the BST.
Note: next() and hasNext() should run in average O(1) time and uses O(h) memory, where h is the height of the tree.
Solution:
# Definition for a binary tree node # class TreeNode(object): # def __init__(self, x): # self.</description>
    </item>
    
    <item>
      <title>Two Sum II Input Array Is Sorted</title>
      <link>http://www.hashnopolis.com/post/2018/09/two-sum-ii-input-array-is-sorted/</link>
      <pubDate>Fri, 07 Sep 2018 23:53:18 +0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/09/two-sum-ii-input-array-is-sorted/</guid>
      <description>Given an array of integers that is already sorted in ascending order, find two numbers such that they add up to a specific target number.
The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2.
Note: - Your returned answers (both index1 and index2) are not zero-based. - You may assume that each input would have exactly one solution and you may not use the same element twice.</description>
    </item>
    
    <item>
      <title>Best Time to Buy and Sell Stock Ii</title>
      <link>http://www.hashnopolis.com/post/2018/09/best-time-to-buy-and-sell-stock-ii/</link>
      <pubDate>Thu, 06 Sep 2018 23:39:13 +0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/09/best-time-to-buy-and-sell-stock-ii/</guid>
      <description>Say you have an array for which the ith element is the price of a given stock on day i.
Design an algorithm to find the maximum profit. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times).
Note: You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again).</description>
    </item>
    
    <item>
      <title>Best Time to Buy and Sell Stock</title>
      <link>http://www.hashnopolis.com/post/2018/09/best-time-to-buy-and-sell-stock/</link>
      <pubDate>Thu, 06 Sep 2018 23:37:49 +0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/09/best-time-to-buy-and-sell-stock/</guid>
      <description>Say you have an array for which the ith element is the price of a given stock on day i.
If you were only permitted to complete at most one transaction (i.e., buy one and sell one share of the stock), design an algorithm to find the maximum profit.
Note that you cannot sell a stock before you buy one.
Example 1:
Input: [7,1,5,3,6,4] Output: 5 Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.</description>
    </item>
    
    <item>
      <title>Add Binary</title>
      <link>http://www.hashnopolis.com/post/2018/09/add-binary/</link>
      <pubDate>Wed, 05 Sep 2018 23:48:48 +0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/09/add-binary/</guid>
      <description>Given two binary strings, return their sum (also a binary string).
The input strings are both non-empty and contains only characters 1 or 0.
Example 1:
Input: a = &amp;quot;11&amp;quot;, b = &amp;quot;1&amp;quot; Output: &amp;quot;100&amp;quot;  Example 2:
Input: a = &amp;quot;1010&amp;quot;, b = &amp;quot;1011&amp;quot; Output: &amp;quot;10101&amp;quot;  Solution:
class Solution: def addBinary(self, a, b): &amp;quot;&amp;quot;&amp;quot; :type a: str :type b: str :rtype: str &amp;quot;&amp;quot;&amp;quot; result = [] carry = 0 i = len(a)-1 j = len(b)-1 while carry or i &amp;gt;= 0 or j &amp;gt;= 0: total = carry if i &amp;gt;= 0: total += int(a[i]) i -= 1 if j &amp;gt;= 0: total += int(b[j]) j -= 1 result.</description>
    </item>
    
    <item>
      <title>17. Letter Combinations of a Phone Number</title>
      <link>http://www.hashnopolis.com/post/2018/09/17.-letter-combinations-of-a-phone-number/</link>
      <pubDate>Mon, 03 Sep 2018 00:28:45 +0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/09/17.-letter-combinations-of-a-phone-number/</guid>
      <description>Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent.
A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.
Example:
Input: &amp;quot;23&amp;quot; Output: [&amp;quot;ad&amp;quot;, &amp;quot;ae&amp;quot;, &amp;quot;af&amp;quot;, &amp;quot;bd&amp;quot;, &amp;quot;be&amp;quot;, &amp;quot;bf&amp;quot;, &amp;quot;cd&amp;quot;, &amp;quot;ce&amp;quot;, &amp;quot;cf&amp;quot;].  Note:
Although the above answer is in lexicographical order, your answer could be in any order you want.</description>
    </item>
    
    <item>
      <title>18. 4Sum</title>
      <link>http://www.hashnopolis.com/post/2018/08/18.-4sum/</link>
      <pubDate>Fri, 31 Aug 2018 23:30:43 +0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/08/18.-4sum/</guid>
      <description>Given an array nums of n integers and an integer target, are there elements a, b, c, and d in nums such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target.
Note:
The solution set must not contain duplicate quadruplets.
Example:
Given array nums = [1, 0, -1, 0, -2, 2], and target = 0. A solution set is: [ [-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2] ]  </description>
    </item>
    
    <item>
      <title>Two Sum</title>
      <link>http://www.hashnopolis.com/post/2018/08/two-sum/</link>
      <pubDate>Wed, 29 Aug 2018 00:44:49 +0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/08/two-sum/</guid>
      <description>Given an array of integers, return indices of the two numbers such that they add up to a specific target.
You may assume that each input would have exactly one solution, and you may not use the same element twice.
Example:
Given nums = [2, 7, 11, 15], target = 9, Because nums[0] + nums[1] = 2 + 7 = 9, return [0, 1].  Solution:
# time: o(n) # space: o(n) class Solution: def twoSum(self, nums, target): &amp;quot;&amp;quot;&amp;quot; :type nums: List[int] :type target: int :rtype: List[int] &amp;quot;&amp;quot;&amp;quot; res = [-1, -1] if nums == None or len(nums) &amp;lt; 2: return res solutionMap = {} for pos in range(len(nums) - 1): if (target - nums[pos]) in solutionMap: res[0] = solutionMap[target - nums[pos]] res[1] = pos break solutionMap[nums[pos]] = pos return res  </description>
    </item>
    
    <item>
      <title>16. 3sum Closest</title>
      <link>http://www.hashnopolis.com/post/2018/08/16.-3sum-closest/</link>
      <pubDate>Mon, 27 Aug 2018 23:30:43 +0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/08/16.-3sum-closest/</guid>
      <description>Given an array nums of n integers and an integer target, find three integers in nums such that the sum is closest to target. Return the sum of the three integers. You may assume that each input would have exactly one solution.
Example:
Given array nums = [-1, 2, 1, -4], and target = 1. The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).</description>
    </item>
    
    <item>
      <title>15. 3sum</title>
      <link>http://www.hashnopolis.com/post/2018/08/15.-3sum/</link>
      <pubDate>Mon, 27 Aug 2018 23:29:18 +0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/08/15.-3sum/</guid>
      <description>Given an array nums of n integers, are there elements a, b, c in nums such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.
Note:
The solution set must not contain duplicate triplets.
Example:
Given array nums = [-1, 0, 1, 2, -1, -4], A solution set is: [ [-1, 0, 1], [-1, -1, 2] ]  Solution:</description>
    </item>
    
    <item>
      <title>57. Insert Interval</title>
      <link>http://www.hashnopolis.com/post/2018/08/57.-insert-interval/</link>
      <pubDate>Sun, 26 Aug 2018 00:43:48 +0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/08/57.-insert-interval/</guid>
      <description>Given a set of non-overlapping intervals, insert a new interval into the intervals (merge if necessary).
You may assume that the intervals were initially sorted according to their start times.
Example 1:
Input: intervals = [[1,3],[6,9]], newInterval = [2,5] Output: [[1,5],[6,9]]  Example 2:
Input: intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8] Output: [[1,2],[3,10],[12,16]] Explanation: Because the new interval [4,8] overlaps with [3,5],[6,7],[8,10].  Solution:
# Definition for an interval. # class Interval: # def __init__(self, s=0, e=0): # self.</description>
    </item>
    
    <item>
      <title>56. Merge Intervals</title>
      <link>http://www.hashnopolis.com/post/2018/08/56.-merge-intervals/</link>
      <pubDate>Fri, 24 Aug 2018 02:19:05 +0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/08/56.-merge-intervals/</guid>
      <description>Given a collection of intervals, merge all overlapping intervals.
Example 1:
Input: [[1,3],[2,6],[8,10],[15,18]] Output: [[1,6],[8,10],[15,18]] Explanation: Since intervals [1,3] and [2,6] overlaps, merge them into [1,6].  Example 2:
Input: [[1,4],[4,5]] Output: [[1,5]] Explanation: Intervals [1,4] and [4,5] are considerred overlapping.  Solution:
# Definition for an interval. # class Interval: # def __init__(self, s=0, e=0): # self.start = s # self.end = e class Solution: def merge(self, intervals): &amp;quot;&amp;quot;&amp;quot; :type intervals: List[Interval] :rtype: List[Interval] &amp;quot;&amp;quot;&amp;quot; intervals.</description>
    </item>
    
    <item>
      <title>80. Remove Duplicates From Sorted Array II</title>
      <link>http://www.hashnopolis.com/post/2018/08/80.-remove-duplicates-from-sorted-array-ii/</link>
      <pubDate>Fri, 24 Aug 2018 00:48:48 +0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/08/80.-remove-duplicates-from-sorted-array-ii/</guid>
      <description>Given a sorted array nums, remove the duplicates in-place such that duplicates appeared at most twice and return the new length.
Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.
Example 1:
Given nums = [1,1,1,2,2,3], Your function should return length = 5, with the first five elements of nums being 1, 1, 2, 2 and 3 respectively.</description>
    </item>
    
    <item>
      <title>Remove Duplicates From Sorted Array</title>
      <link>http://www.hashnopolis.com/post/2018/08/remove-duplicates-from-sorted-array/</link>
      <pubDate>Thu, 23 Aug 2018 23:52:17 +0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/08/remove-duplicates-from-sorted-array/</guid>
      <description>Given a sorted array nums, remove the duplicates in-place such that each element appear only once and return the new length.
Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.
Example 1:
Given nums = [1,1,2], Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively. It doesn&#39;t matter what you leave beyond the returned length.</description>
    </item>
    
    <item>
      <title>4. Median of Two Sorted Arrays</title>
      <link>http://www.hashnopolis.com/post/2018/08/4.-median-of-two-sorted-arrays/</link>
      <pubDate>Tue, 21 Aug 2018 20:54:32 +0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/08/4.-median-of-two-sorted-arrays/</guid>
      <description>There are two sorted arrays nums1 and nums2 of size m and n respectively.
Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).
You may assume nums1 and nums2 cannot be both empty.
Example 1:
nums1 = [1, 3] nums2 = [2]  The median is 2.0
Example 2:
nums1 = [1, 2] nums2 = [3, 4]  The median is (2 + 3)/2 = 2.</description>
    </item>
    
    <item>
      <title>Remove Nth Node From End of List</title>
      <link>http://www.hashnopolis.com/post/2018/08/remove-nth-node-from-end-of-list/</link>
      <pubDate>Mon, 20 Aug 2018 23:33:38 +0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/08/remove-nth-node-from-end-of-list/</guid>
      <description>Given a linked list, remove the n-th node from the end of list and return its head.
Example:
Given linked list: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5, and n = 2. After removing the second node from the end, the linked list becomes 1-&amp;gt;2-&amp;gt;3-&amp;gt;5.  Note:
Given n will always be valid.
Follow up:
Could you do this in one pass?</description>
    </item>
    
    <item>
      <title>Search in Rotated Sorted Array II</title>
      <link>http://www.hashnopolis.com/post/2018/08/search-in-rotated-sorted-array-ii/</link>
      <pubDate>Wed, 15 Aug 2018 12:50:21 +0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/08/search-in-rotated-sorted-array-ii/</guid>
      <description>Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.
(i.e., [0,0,1,2,2,5,6] might become [2,5,6,0,0,1,2]).
You are given a target value to search. If found in the array return true, otherwise return false.
Example 1:
Input: nums = [2,5,6,0,0,1,2], target = 0 Output: true  Example 2:
Input: nums = [2,5,6,0,0,1,2], target = 3 Output: false  Follow up: - This is a follow up problem to Search in Rotated Sorted Array, where nums may contain duplicates.</description>
    </item>
    
  </channel>
</rss>